module Behavior2Maude; -- Module Template
create OUT : Maude from IN : Behavior, INATL : ATL;

--CAMBIOS: A�adir los ActionExec como un elemento m�s en cada Pattern como participantes de las acciones

-- En general se ha optado por utilizar m�s lazy rules que matched rules debido a que por cada elemento del
-- modelo de entrada se van a generar muchos elementos repetidos en diferentes puntos de la transformaci�n.

-- Las variables que pueden aparecer en las expresiones OCL se van a declarar de tipo OCL-Type. Esto afecta a los identificadores
-- de objetos, y a variables. En un principio los identificadores de objetos eran definidos de tipo Oid, ha sido necesario 
-- cambiar su tipo porque el parseador de OCL a modelo no distingue entre unos elementos y otros y se creaba un conflicto
-- de tipos

------------------------------------------------------------------------------------------------
---- Helper para poner los nombres con la nomenclatura de atributo@clase@paquete ---------------
helper context Behavior!EPackage def : maudeName() : String =
    if (self.eSuperPackage.oclIsUndefined())then 
		self.name
    else 
    	self.name + '@' + self.eSuperPackage.maudeName()  
    endif; 
helper context Behavior!EClassifier def : maudeName() : String =
    if (self.ePackage.oclIsUndefined())then 
		self.name
    else 
    	self.name + '@' + self.ePackage.maudeName()  
    endif; 
helper context Behavior!EStructuralFeature def : maudeName() : String =
    self.name + '@' + self.eContainingClass.maudeName();
helper context Behavior!EEnumLiteral def : maudeName() : String =
	self.name + '@' + self.eEnum.maudeName();
---------------------------------------------------------------------------------------------------------

--- Maude does not work right '`' '_' and ' ' are keyword characters ------------------------------------
helper context String def : processSpecOpChars() : String =
	self.regexReplaceAll('`','@\'@').regexReplaceAll('_','@-@').regexReplaceAll(' ','@#@');

helper context String def : processSpecModChars() : String =
   self.replaceAll('{','-').replaceAll('}','-').replaceAll('(','-').replaceAll(')','-').replaceAll('[','-')
	.replaceAll(']','-').replaceAll(',','-').replaceAll(' ','-');
---------------------------------------------------------------------------------------------------------

-------- Check whether a reference is simple, maybe, ordset, etc...
helper context OclAny def: refType() : Maude!Sort =
  if self.upperBound=1 then
    if self.lowerBound=0 then
	  thisModule.sortRefMaybe
	else
	  thisModule.sortRefSimple
	endif
  else
    if self.isUnique() then
	  if self.isOrdered() then
        thisModule.sortRefOrderedSet
	  else
		thisModule.sortRefSet
	  endif
    else
	  if self.isOrdered() then
		thisModule.sortRefSequence
	  else
		thisModule.sortRefBag
	  endif
    endif
  endif;

--------Determina si un OID es Simple, Maybe, OrderedSet, Set, Sequence o Bag--------------------
helper context OclAny def: oidType() : Maude!Sort =
	if self.upperBound=1 then
		if self.lowerBound=0 then
			thisModule.sortOidMaybe
		else
			thisModule.sortOid
		endif
	else
		if self.isUnique() then
			if self.isOrdered() then
				thisModule.sortOidOrderedSet
			else
				thisModule.sortOidSet
			endif
		else
			if self.isOrdered() then
				thisModule.sortOidSequence
			else
				thisModule.sortOidBag
			endif
		endif
	endif;

-------------Determina si un SLOT es de tipo Attribute o Reference-----------
helper context OclAny def: slotType() : Maude!Sort = 
	if self.oclIsTypeOf(Behavior!EAttribute) then thisModule.sortAttribute
	else thisModule.sortRefSimple
	endif;

-------------Determina si una INSTANCE es de tipo Attribute o Reference-----------
helper context OclAny def: TypeOfInstance() : Maude!Sort = 
	if self.oclIsTypeOf(Behavior!EAttribute) then thisModule.sortAttInst
	else thisModule.sortRefInst
	endif;

-------------Determina si el TIPO de una STRUCTURAL FEATURE-----------
helper context OclAny def: structFeatType() : Maude!Sort = 
	if self.oclIsTypeOf(Behavior!EAttribute) then self.maudeBasicType()
	else self.oidType()
	endif;

helper context OclAny def: maudeBasicType() : Maude!Sort =
	if (self.eType.name = 'EBoolean' or self.eType.name = 'Boolean' 
			or self.eType.name = 'EBooleanObject') 
	then thisModule.boolSort 
	else if (self.eType.name = 'EFloat' or self.eType.name = 'Double' 
			or self.eType.name = 'EDouble' or self.eType.name = 'EDoubleObject'
			or self.eType.name = 'EFloatObject') 
		then thisModule.floatSort
		else if (self.eType.name = 'EInt' or self.eType.name = 'Integer'
				or self.eType.name = 'EIntegerObject') 
			then  thisModule.intSort
			else if (self.eType.name = 'EString' or self.eType.name = 'String') 
				then thisModule.stringSort
					else if (self.eType.oclIsKindOf(Behavior!EEnum))  
					then thisModule.enumerationSort(self)
					else thisModule.dataTypeInstanceSort
					endif
				endif
			endif
		endif
	endif;

---Helper para calcular el incremento del COUNTER --------------
---En la Realization Rule el incremento del Contador ser� de 2*n�mero de objetos creados
---(uno por el objeto y otro por el object role)
helper context Behavior!Rule def: numObjInRhs() : Integer =
	2*(self.NewObjActExecRHS()->size());

helper context Behavior!Rule def: numObjInRhsAux() : Integer =
	self.NewObjActExecRHS()->size();

---Para el caso de las Reglas Instantaneas el incremento se calcula de forma diferente ya que no hay
---Realization Rule. Ahora a lo anterior hay que añadir una unidad de tiempo por cada objeto de la parte
---izquierda(correspondiente a la creacion del identificador de su OR)
helper context Behavior!Rule def: numObjCreatedInstantaneous() : Integer =
	2*(self.NewObjActExecRHS()->size())+self.objActExecLHSRule()->size();

helper context Behavior!Rule def: numObjCreatedInstantaneousAux() : Integer =
	self.NewObjActExecRHS()->size()+self.objActExecLHSRule()->size();

--DADO UN OBJETO,DEVUELVE UNA COLECCION DE LOS SLOTS O DE LOS LINKS DEL MISMO QUE ESTAN EN LHS PERO NO EN RHS O VICEVERSA(segun el caso) 
-------Toma un objeto que esta en LHS y RHS y devuelve los LINKs del objeto en RHS que NO estan en LHS------------
helper context Behavior!Pattern def : getRHSLinksNoIni(obj:Behavior!Object):Sequence(Behavior!Link)=
	self."rule".objectsRHSRule()->collect(i|i.outLinks)->flatten()->
	select(k|(k.src.id=obj.id) and obj.outLinks->collect(t|t.ref.name)->excludes(k.ref.name));

-------Toma un objeto que esta en LHS y RHS y devuelve los SLOTs del objeto en RHS que NO estan en LHS------------
helper context Behavior!Pattern def : getRHSSlotsNoIni(obj:Behavior!Object):Sequence(Behavior!Slot)=
	self."rule".objectsRHSRule()->collect(i|i.sfs)->flatten()->
	select(k|(k.object.id=obj.id) and obj.sfs->collect(t|t.sf.name)->excludes(k.sf.name));

-------Toma un objeto que esta en LHS y RHS y devuelve los LINKs de �ste en LHS que NO estan en RHS------------
helper context Behavior!Pattern def : getLHSLinksNoIni(obj:Behavior!Object):Sequence(Behavior!Link)=
	self."rule".objectsLHSRule()->collect(i|i.outLinks)->flatten()->
	select(k|(k.src.id=obj.id) and obj.outLinks->collect(t|t.ref.name)->excludes(k.ref.name));

-------Toma un objeto que esta en LHS y RHS y devuelve los SLOTs de �ste en LHS que NO estan en RHS------------
helper context Behavior!Pattern def : getLHSSlotsNoIni(obj:Behavior!Object):Sequence(Behavior!Slot)=
	self."rule".objectsLHSRule()->collect(i|i.sfs)->flatten()->
	select(k|(k.object.id=obj.id) and obj.sfs->collect(t|t.sf.name)->excludes(k.sf.name));
---------------------------------------------------------------------------------------------------------------

--DADO UN OBJETO, SI EST� EN LHS Y EN RHS DEVUELVE UNA COLECCI�N CON LOS LINKS O SLOTS DEL MISMO EN LHS O EN RHS
-----Toma un objeto que esta en LHS y si est� en RHS devuelve los LINKs de �ste en RHS---------------
helper context Behavior!Pattern def : getLinksRHS(obj:Behavior!Object):Sequence(Behavior!Link)=
	self."rule".objectsRHSRule()->collect(i|i.outLinks)->flatten()->
	select(k|(k.src.id=obj.id));

-----Toma un objeto que esta en RHS y si est� en LHS y devuelve los LINKs de �ste en LHS---------------
helper context Behavior!Pattern def : getLinksLHS(obj:Behavior!Object):Sequence(Behavior!Link)=
	self."rule".objectsLHSRule()->collect(i|i.outLinks)->flatten()->
	select(k|(k.src.id=obj.id));

-----Toma un objeto que esta en LHS y RHS y devuelve los SLOTs de �ste en RHS---------------
helper context Behavior!Pattern def : getSlotsRHS(obj:Behavior!Object):Sequence(Behavior!Slot)=
	self."rule".objectsRHSRule()->collect(i|i.sfs)->flatten()->
	select(k|(k.object.id=obj.id));

-----Toma un objeto que esta en LHS y RHS y devuelve los SLOTs de �ste en LHS---------------
helper context Behavior!Pattern def : getSlotsLHS(obj:Behavior!Object):Sequence(Behavior!Slot)=
	self."rule".objectsLHSRule()->collect(i|i.sfs)->flatten()->
	select(k|(k.object.id=obj.id));
----------------------------------------------------------------------------------------------

-- Devuelve un Booleano que indica si el PATTERN es del tipo RHS ------
helper context Behavior!Pattern def: isRHSPattern() : Boolean =
	self."rule".rhs = self;

-- Dado un objeto y un Pattern RHS devuelve un booleano que indica si el objeto esta contenido en ese Pattern --
helper context Behavior!Object def : existObjInRHS(p:Behavior!Pattern) : Boolean =
	p."rule".rhs.els->select(i|i.oclIsTypeOf(Behavior!Object))->exists(x|x.id=self.id);

-- Dado un objeto y un Pattern LHS devuelve un booleano que indica si el objeto esta contenido en ese Pattern --
helper context Behavior!Object def : existObjInLHS(p:Behavior!Pattern) : Boolean =
	p."rule".lhs.els->select(i|i.oclIsTypeOf(Behavior!Object))->exists(x|x.id=self.id);

-- Devuelve la lista de OBJECTS del LHS de una rule
helper context Behavior!Rule def : objectsLHSRule(): Sequence(Behavior!Object) =
	self.lhs.els -> select(o|o.oclIsTypeOf(Behavior!Object)) ;

-- Devuelve la lista de OBJECTS del RHS de una rule
helper context Behavior!Rule def : objectsRHSRule(): Sequence(Behavior!Object)=
	self.rhs.els -> select(o|o.oclIsTypeOf(Behavior!Object)) ;

-- Devuelve la lista de ACTIONEXEC de un PATTERN de una rule
helper context Behavior!Pattern def : ActionExecEls(): Sequence(Behavior!ActionExec) =
	self.els -> select(o|o.oclIsTypeOf(Behavior!ActionExec)) ;

-- Devuelve la lista de los NACs de una Rule 
helper context Behavior!Rule def : NACSRule(): Sequence(Behavior!NAC)=
	self.els ->select(e|e.oclIsTypeOf(Behavior!NAC));

----- Devuelve una lista con los OBJECTS y ACTIONEXEC de LHS---- 
helper context Behavior!Rule def : objActExecLHSRule(): Sequence(Behavior!PatternEl) =
	self.lhs.els -> select(i|i.oclIsTypeOf(Behavior!Object) or i.oclIsTypeOf(Behavior!ActionExec));

----- Devuelve una lista con los OBJECTS y ACTIONEXEC de RHS----
helper context Behavior!Rule def : objActExecRHSRule(): Sequence(Behavior!PatternEl) =
	self.rhs.els -> select(i|i.oclIsTypeOf(Behavior!Object) or i.oclIsTypeOf(Behavior!ActionExec));

-- Devuelve los OBJECTS y ACTIONEXEC de una rule que est�n presentes en LHS pero no en RHS (es decir los elementos borrados)
helper context Behavior!Rule def: deletedElements() : Sequence(Behavior!PatternEl)= --Sequence(Behavior!Object)=
	self.objectsLHSRule() -> select(o|self.objectsRHSRule()->collect(j|j.id)->excludes(o.id))->
	union(self.lhs.ActionExecEls()->select(y|self.rhs.ActionExecEls()->collect(j|j.id)->excludes(y.id)));

-- Devuelve los OBJECTS de una rule que est�n presentes en LHS pero no en RHS (es decir los OBJECTS borrados)
helper context Behavior!Rule def: deletedObjects() : Sequence(Behavior!Object)= --Sequence(Behavior!Object)=
	self.objectsLHSRule() -> select(o|self.objectsRHSRule()->collect(j|j.id)->excludes(o.id));

-- Devuelve la lista de OBJECTs de un determinado PATTERN
helper context Behavior!Pattern def: patternObjects() : Sequence(Behavior!Object) =
	self.els->select(i|i.oclIsTypeOf(Behavior!Object));

-- Devuelve la lista de ACTIONEXECs de un determinado PATTERN
helper context Behavior!Pattern def: patternActionExec() : Sequence(Behavior!ActionExec) =
	self.els->select(i|i.oclIsTypeOf(Behavior!ActionExec));

-- Devuelve la lista de OBJECTs y ACTIONEXECs de un determinado PATTERN
helper context Behavior!Pattern def: patternObjActExec() : Sequence(Behavior!PatternEl) =
	self.els->select(i|i.oclIsTypeOf(Behavior!Object) or i.oclIsTypeOf(Behavior!ActionExec));

-- Devuelve la lista de LINKs de un determinado PATTERN
helper context Behavior!Pattern def: linksRule(): Sequence(Behavior!Link)=
	self.els -> select(i|i.oclIsTypeOf(Behavior!Link));

-- Devuelve un booleano indicando si un OBJECT esta en el RHS de una rule y tiene Structural Features
helper context Behavior!Pattern def : existsSFInRhs(obj:Behavior!Object): Boolean =
	((obj.existObjInRHS(self)) and (self.getSlotsRHS(obj)->notEmpty() or self.getLinksRHS(obj)->notEmpty() or obj.getOppositeLinksRHS()->notEmpty() ));

-- Devuelve un booleano indicando si un OBJECT tiene SLOTs o LINKs
helper context Behavior!Object def : existsStructFeat(): Boolean =
	self.sfs->notEmpty() or self.outLinks->notEmpty() or self.inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())->notEmpty();
	
-- Devuelve un booleano indicando si un objeto esta contenido en LHS de la regla y si tiene
-- Slots o Links en LHS
helper context Behavior!Pattern def : existsSFInLhs(obj:Behavior!Object): Boolean =
	((obj.existObjInLHS(self)) and (self.getSlotsLHS(obj)->notEmpty() or self.getLinksLHS(obj)->notEmpty() or obj.getOppositeLinksLHS()->notEmpty()   ));

--Dada una regla devuelve el conjunto de Objetos de RHS que NO est�n en LHS
helper context Behavior!Rule def: NewObjectsRHS() : Sequence(Behavior!Object)=
	self.objectsRHSRule()->select(i|self.objectsLHSRule()->collect(j|j.id)->excludes(i.id));

--Dada una regla devuelve el conjunto de Objetos y ActionExec de RHS que NO estan en LHS
helper context Behavior!Rule def: NewObjActExecRHS() : Sequence(Behavior!PatternEl)=
	self.objActExecRHSRule()->select(i|self.objActExecLHSRule()->collect(j|j.id)->excludes(i.id));

--Helpers de tipo atributo para colleccionar diversos elementos
--Crean colecciones de elementos de todo el modelo y que ser�n necesarias en algunos puntos de latransformaci�n
helper def : allBehaviorElements : Sequence(Behavior!Behavior) =
	Behavior!Behavior.allInstances();

--Devuelve una coleccion con todas las expresiones Ocl
helper def : allOclExpressions : Sequence(ATL!Attribute) = 
	ATL!Attribute.allInstances();

--Helpers para calcular cuantas veces aparece la funcion random de eMotions
--Dicho numero se utiliza para generar el numero aleatorio 
helper def : numberOfRandoms : Integer =
	ATL!OperationCallExp.allInstances()->select(i|i.randomExpression() and i.source.auxNumberOfRandoms())->size();

helper context ATL!OclExpression def : randomExpression() : Boolean =
	self.operationName='random' or self.operationName='expDistr' or self.operationName='weibDistr' 
		or self.operationName='normDistr' or self.operationName='gammaDistr' or self.operationName='chiSDistr'
		or self.operationName='erlangDistr' or self.operationName='fDistr' or self.operationName='geomDistr'
		or self.operationName='logNormDistr' or self.operationName='pascalDistr' or self.operationName='paretDistr'
		or self.operationName='unifDistr' or self.operationName='doublePDF' or self.operationName='parseExp';

helper context ATL!OclExpression def : auxNumberOfRandoms() : Boolean =
	if not self.oclIsUndefined() then
		if self.oclIsTypeOf(ATL!VariableExp) then
			self.referredVariable.varName='eMotions'
		else
			false
		endif
	else
		false
	endif;

--Atributo que contiene una coleccion de todas las Atomic Rule
helper def : allAtomicRules : Sequence(Behavior!AtomicRule) =
	Behavior!AtomicRule.allInstances();

--Atributo que contiene una coleccion de todas las Structural Features 
helper def : allStructuralFeatures : Sequence(Behavior!EStructuralFeature) = 
	thisModule.allBehaviorElements->first().metamodelGD->collect(x|x.packagesGD)->flatten()->collect(i|i.classesGD)->flatten()->collect(j|j.class)->collect(r|r.eStructuralFeatures)->flatten(); -- ->collect(s|s.maudeName());

--Atributo que contiene una coleccion con todas las Clases del Metamodelo del que se va a describir el comportamiento.
helper def : allClasses : Sequence(Behavior!EClass) =
	thisModule.allBehaviorElements->first().metamodelGD->collect(x|x.packagesGD)->flatten()->collect(i|i.classesGD)->flatten()->collect(j|j.class);

--Atributo que contiene una colecci�n con todas los Enumerados del Metamodelo del que se va a describir el comportamiento.
helper def : allEnums : Sequence(Behavior!EEnum) =
	thisModule.allBehaviorElements->first().metamodelGD->collect(x|x.packagesGD)->flatten()->collect(v|v.package)->collect(x|x.eClassifiers)->flatten()->select(i|i.oclIsTypeOf(Behavior!EEnum))->flatten();

--Helper para obtener el nombre del Package de una clase
--Se utiliza cuando aparece el nombre de una clase en una expresi�n OCL
helper context ATL!VariableExp def : packageName() : String =
	thisModule.allClasses->any(j|j.name=self.referredVariable.varName).ePackage.name;

helper context ATL!EnumLiteralExp def : getEnumObject() : Behavior!EEnum =
	thisModule.allEnums->any(j|j.eLiterals->one(w|w.toString()=self.name));
	
helper context ATL!EnumLiteralExp def : enumLiteralName() : String =
	self.name+'@'+self.getEnumObject().name+'@'+self.getEnumObject().ePackage.name;

--Devuelve el conjunto de Variables de una Rule
helper context Behavior!Rule def : allVariables : Sequence(Behavior!Variable) =
	self.vbles;

--Helper que dado un Link llama a una lazy rule u otra dependiendo de si est� definido el atributo de posici�n del mismo.
helper context Behavior!Link def : LinkComputation() : Maude!BooleanCond =
	if self.pos.oclIsUndefined() or self.pos='' then thisModule.LinkCondition(self)
	else thisModule.LinkPosCondition(self)
	endif;

helper def : RefWithoutDuplicates( inCollection : Sequence(Behavior!Link) ) : Sequence(Behavior!EReference) =
	inCollection -> iterate(e; outCollection : Sequence(Behavior!EReference) = Sequence{} |
		if outCollection ->one(i|i=e.ref) then outCollection
		else outCollection ->append(e.ref)
		endif);

helper context Behavior!EReference def : LinksWithConcreteRef(links : Sequence(Behavior!Link)) : Sequence(Behavior!Link) =
	links->select(i|i.ref=self);
	
helper context Behavior!Object def : OppositeLinks() : Sequence(Behavior!EReference) =
	self.inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())->collect(j|j.ref.getEOpposite())->asSet()->asSequence();

--Dado un objeto de RHS, devuelve las referencias opuestas que tiene ese mismo objeto en LHS y que no est�n en RHS (si el objeto tambi�n est� presente en LHS)  
helper context Behavior!Object def : OppositeLHSLinksNiIni() : Sequence(Behavior!EReference) =
	if self.SameObjInLHS().oclIsUndefined() then Sequence{}
	else
		self.SameObjInLHS().inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())
			->select(r| self.inLinks->collect(t|t.ref.eOpposite)->excludes(r.ref.eOpposite))
				->collect(j|j.ref.getEOpposite())->asSet()->asSequence()
	endif;

--Dado un objeto de LHS, devuelve las referencias opuestas que tiene ese mismo objeto en LHS y que no est�n en RHS (si el objeto tambi�n est� presente en LHS)
helper context Behavior!Object def : OppositeRHSLinksNiIni() : Sequence(Behavior!EReference) =
	if self.SameObjInRHS().oclIsUndefined() then Sequence{}
	else
		self.inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())
			->select(r| self.SameObjInRHS().inLinks->collect(t|t.ref.eOpposite)->excludes(r.ref.eOpposite))
				->collect(j|j.ref.getEOpposite())->asSet()->asSequence()
	endif;

--Dado un objeto de LHS: - si ese objeto existe en RHS devuelve los Links de ese mismo objeto en RHS
--						 - si el objeto no existe en RHS devuelve un Sequence vacio
helper context Behavior!Object def : getOppositeLinksRHS():Sequence(Behavior!EReference)=
	if self.SameObjInRHS().oclIsUndefined() then Sequence{} 
	else
		self.SameObjInRHS().inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())->collect(j|j.ref.getEOpposite())
	endif;

--Dado un objeto de LHS devuelve el conjunto de Links de dicho objeto en RHS que no est�n en LHS
helper context Behavior!Object def : getOppositeLinksRHSThatNotAreInLHS():Sequence(Behavior!EReference)=
	if self.SameObjInRHS().oclIsUndefined() then Sequence{} 
	else
		self.SameObjInRHS().inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())
			->select(r|self.inLinks->collect(t|t.ref.eOpposite)->excludes(r.ref.eOpposite))
				->collect(j|j.ref.getEOpposite())->asSet()->asSequence()
	endif;

helper context Behavior!Object def : getOppositeLinksLHS():Sequence(Behavior!EReference)=
	if self.SameObjInLHS().oclIsUndefined() then Sequence{} --OclUndefined 
	else
		self.SameObjInLHS().inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())->collect(j|j.ref.getEOpposite())
	endif;
	
--Dado un objeto y una referencia devuelve todos los "Links Opuestos" de ese objetos de ese tipo de referencia
helper context Behavior!Object def : GetOppositeLinks(r : Behavior!EReference) : Sequence(Behavior!Link) =
	self.inLinks->select(i|not i.ref.eOpposite.oclIsUndefined())->select(j|j.ref.eOpposite=r);

helper def : AllObjectReferences(r:Sequence(Behavior!EReference),op:Sequence(Behavior!EReference)) : Sequence(Behavior!EReference) =
	r->union(op)->asSet()->asSequence();
	
helper context Behavior!ActionExec def : ActExecExistsInRHS() : Boolean =
	self.pattern."rule".rhs.patternActionExec()->exists(i|i.id=self.id) ;

helper context Behavior!Rule def : SlotsOfReferences() : Sequence(Behavior!Slot) =
	self.objectsRHSRule()->collect(i|i.sfs)->flatten()->select(j|j.sf.oclIsTypeOf(Behavior!EReference))->select(k|not k.sf.eOpposite.oclIsUndefined());

---------------------------------------------
----- Definicion de variables globales-------
---------------------------------------------

helper def : setOfRandoms : Set(Maude!Constant) = OclUndefined;

------- Counters
--Se utilizan en las partes imperativas para asignar la numeraci�n a las variables de los ObjectRole
--las variables y para la inicializaci�n de las mismas. Adem�s sirven para llevar la cuenta del contador.
helper def : counter : Integer = 0;
helper def : counter2 : Integer = 0;
helper def : counter3 : Integer = 0;
helper def : counterRhs : Integer = 0;
helper def : counterTimerPre : Integer = 0;
helper def : counterOpTimer : Integer = 0;
helper def : counterVar : Integer = 0;
helper def : counterV : Integer = 0;
helper def : counterVbles : Integer = 0;
helper def : counterObR : Integer = 0;
helper def : newCounter : Integer = 0;
helper def : counterX : Integer = 0; 
helper def : counterObjR : Integer = 0;
helper def : countORAE : Integer = 0;
helper def : counterRules : Integer = 0;
helper def : counterRandom : Integer = 0;
-------------------------------------------
helper def : objectOperator : String = '<_:_|_>';
helper def : modelOperator : String = '_`{_`}';

helper def : mSetOperator : String = '_;_';
helper def : featOperator : String = '_#_';
helper def : listOrdOperator : String = '_;_';
helper def : sfsOperator : String = '_:_';
helper def : objSetOperator : String = '__';
helper def : inOperator : String = '_in_';
helper def : orElseOperator : String = '_or-else_';
helper def : insertOp : String = 'insert';
helper def : insertAtOp : String = 'insertAt';
helper def : oidMetamodel : String = 'MM@';
helper def : nullOperator : String = 'null';
helper def : varEmptyOp : String = 'none';
helper def : listOp : String = '__';
helper def : evalOperator : String = 'eval'; --'eval(_`,_`,_)';
helper def : ctxOperator : String = '_<-_';
helper def : mtOperator : String = 'mt';
helper def : mtordOperator : String = 'mt-ord';
helper def : nilOperator : String = 'nil';
helper def : newIdOperator : String = 'newId'; --'newId(_)';
helper def : setCollection : String = 'Set`{_`}';--'Set_';
helper def : freezeOp : String = 'freeze';
helper def : myLinkListOperator : String = '__';

helper def : notOperator : String = 'not_';
helper def : selfOp : String = 'self';
helper def : emptyOperator : String = 'empty';
helper def : toRatOperator : String = 'toRat'; --'toRat(_)';
helper def : leOperator : String = '_le_';
helper def : gtTOperator : String = '_gtT_';
helper def : readjustOp : String = 'readjust'; --'readjust(_`,_`,_)';
helper def : addRefOperator : String = 'addRef'; --'addRef(_`,_`,_)';
helper def : addRefPosOperator : String = 'addRef'; --'addRef(_`,_`,_`,_)';
helper def : inPeriodOp : String = 'inPeriod'; --'inPeriod(_`,_`,_)';
helper def : plusOp : String = '_plus_';
helper def : multipleOp : String = 'multiple'; --'multiple(_`,_)';
helper def : linkOperator : String = 'link';
helper def : completeOp : String = 'complete';
helper def : updateOp : String = 'update';
helper def : envOperator : String = 'env';

helper def : wrapperOperator : String = '<<_>>';
helper def : equalOperator : String = '_.=._';
helper def : atOperator : String = '_->`at`(_`)';

----------------OCL-------------------------------------
helper def : navOperator : String = '__';
helper def : oclAttrOperator : String = '._';
helper def : functionOperator : String = '._`(`)';
helper def : functionOperatorWithArgs : String = '._`(_`)';
helper def : iterVarOperator : String = '_|_';
helper def : letExpOperator : String = 'let_in_';
helper def : ifExpOperator : String = 'if_then_else_endif';
helper def : vbleDeclOperator : String = '_=_';
helper def : iterateOperator : String = '_->`iterate_';
helper def : iterateExpOperator : String = '_`,_|_';
--------------------------------------------------------

helper def : mSpec : Maude!MaudeSpec = OclUndefined;
helper def : mainModule : Maude!Module = OclUndefined;
helper def : sModuleEMot : Maude!Module = OclUndefined;
helper def : sortModel: Maude!Sort = OclUndefined;
helper def : sortMetamodel: Maude!Sort = OclUndefined;
helper def : sortObject: Maude!Sort = OclUndefined;
helper def : sortSetObject: Maude!Sort = OclUndefined;
helper def : sortStructFeat: Maude!Sort = OclUndefined;
helper def : sortSetSfi: Maude!Sort = OclUndefined;
helper def : sortSetSf: Maude!Sort = OclUndefined;
helper def : sortListOid: Maude!Sort = OclUndefined;
helper def : sortAttribute: Maude!Sort = OclUndefined;
helper def : sortRefSimple: Maude!Sort = OclUndefined;
helper def : sortRefInst: Maude!Sort = OclUndefined;
helper def : sortAttInst: Maude!Sort = OclUndefined;
helper def : sortRefMaybe: Maude!Sort = OclUndefined;
helper def : sortRefSet: Maude!Sort = OclUndefined;
helper def : sortRefOrderedSet: Maude!Sort = OclUndefined;
helper def : sortRefSequence: Maude!Sort = OclUndefined;
helper def : sortRefBag: Maude!Sort = OclUndefined;
helper def : sortOid: Maude!Sort = OclUndefined;
helper def : sortOidMaybe: Maude!Sort = OclUndefined;
helper def : sortOidSet: Maude!Sort = OclUndefined;
helper def : sortOidOrderedSet: Maude!Sort = OclUndefined;
helper def : sortOidSequence: Maude!Sort = OclUndefined;
helper def : sortOidBag: Maude!Sort = OclUndefined;
helper def : stringSort: Maude!Sort = OclUndefined;
helper def : intSort: Maude!Sort = OclUndefined;
helper def : boolSort: Maude!Sort = OclUndefined;
helper def : floatSort: Maude!Sort = OclUndefined;
helper def : realSort: Maude!Sort = OclUndefined;
helper def : dataTypeInstanceSort: Maude!Sort = OclUndefined;
helper def : enumLiteralSort: Maude!Sort = OclUndefined;
helper def : sortClock: Maude!Sort = OclUndefined;
helper def : sortCounter: Maude!Sort = OclUndefined;
helper def : enumSort: Maude!Sort = OclUndefined;
helper def : sortNat: Maude!Sort = OclUndefined;
helper def : sortTime: Maude!Sort = OclUndefined;
helper def : sortObjRole: Maude!Sort = OclUndefined;
helper def : sortAtActExec: Maude!Sort = OclUndefined;
helper def : oclTypeSort: Maude!Sort = OclUndefined;
helper def : oclExpSort: Maude!Sort = OclUndefined;
helper def : envSort: Maude!Sort = OclUndefined;
helper def : vidSort: Maude!Sort = OclUndefined;
helper def : listSort: Maude!Sort = OclUndefined;
helper def : listOrdSort: Maude!Sort = OclUndefined;
helper def : varPairSort: Maude!Sort = OclUndefined;
helper def : emptySort: Maude!Sort = OclUndefined;
helper def : emptySetSort: Maude!Sort = OclUndefined;
helper def : setSort: Maude!Sort = OclUndefined;
helper def : sequenceSort: Maude!Sort = OclUndefined;
helper def : bagSort: Maude!Sort = OclUndefined;
helper def : orderedSetSort: Maude!Sort = OclUndefined;
helper def : myLinkListSort: Maude!Sort = OclUndefined;
helper def : opNameSort: Maude!Sort = OclUndefined;
helper def : variableSort: Maude!Sort = OclUndefined;
helper def : timeSort: Maude!Sort = OclUndefined;
helper def : timeSort2: Maude!Sort = OclUndefined;
helper def : nzTimeSort: Maude!Sort = OclUndefined;
helper def : actExecSort: Maude!Sort = OclUndefined;
helper def : itemListSort: Maude!Sort = OclUndefined;
helper def : itemListOrdSort: Maude!Sort = OclUndefined;
helper def : collectionSort: Maude!Sort = OclUndefined;
helper def : letExpSort: Maude!Sort = OclUndefined;
helper def : vbleDeclSort: Maude!Sort = OclUndefined;
helper def : iterateExpSort: Maude!Sort = OclUndefined;
helper def : oclModule: Maude!Sort = OclUndefined;
helper def : auxiliaryModule: Maude!Sort = OclUndefined;
helper def : userOpNavSort: Maude!Sort = OclUndefined;
helper def : iterVarSort: Maude!Sort = OclUndefined;
helper def : oclAttrSort: Maude!Sort = OclUndefined;
helper def : attributeNameSort: Maude!Sort = OclUndefined;
helper def : attOpSort: Maude!Sort = OclUndefined;
helper def : ratSort: Maude!Sort = OclUndefined;
helper def : sfSort: Maude!Sort = OclUndefined;
helper def : attributeSetSort: Maude!Sort = OclUndefined;
helper def : emptyListSort: Maude!Sort = OclUndefined;
helper def : msgSort: Maude!Sort = OclUndefined;
helper def : actionStatusSort: Maude!Sort = OclUndefined;
helper def : atomicRuleSort: Maude!Sort = OclUndefined;
helper def : mSetSort: Maude!Sort = OclUndefined;

-- Regla de inicializaci�n, con los elementos que se crean independientemente 
-- de la entrada--
entrypoint rule Initialize(){
	to
		mSpec : Maude!MaudeSpec(
			els <- Sequence{mainModule},
			          printableEls <- Sequence{mainModule}),
		mainModule : Maude!SModule(
			name <- thisModule.allBehaviorElements->first().metamodelGD->
			         			iterate(e;res : String = ''|e.name.toUpper().processSpecModChars().processSpecOpChars())+'BEHAVIOR@',
			els <- Sequence{mImportEMot,mImportDTime}),
		mImportDTime : Maude!ModImportation(
			mode <- #protecting,
			imports <- moduleIdModExpDTime,
			"module" <- thisModule.mainModule),
		moduleIdModExpDTime : Maude!ModuleIdModExp(
			"module" <- sModuleDTime),
		sModuleDTime : Maude!SModule(
			name <- if thisModule.allBehaviorElements->first().denseTime then 'DENSE_TIME'
					else 'DISCRETE_TIME'
					endif),
		mImportEMot : Maude!ModImportation(
			mode <- #protecting,
			imports <- moduleIdModExpEMot),
		moduleIdModExpEMot : Maude!ModuleIdModExp(
			"module" <- sModuleEMot),
		sModuleEMot : Maude!SModule(
			name <- 'E-MOTIONS'),
		sortModel : Maude!Sort(
			name <- '@Model',
			"module" <- sModuleEMot
			),
		sortMetamodel : Maude!Sort(
			name <- '@Metamodel',
			"module" <- sModuleEMot
			),
		sortObject : Maude!Sort(
			name <- '@Object',
			"module" <- sModuleEMot
			),
		sortAttribute :Maude!Sort(
			name <- '@Attribute',
			"module" <- sModuleEMot
			),
		sortRefSimple :Maude!Sort(
			name <- '@Reference',
			"module" <- sModuleEMot
			),
		sortRefInst :Maude!Sort(
			name <- '@ReferenceInstance',
			"module" <- sModuleEMot
			),
		sortAttInst :Maude!Sort(
			name <- '@AttributeInstance',
			"module" <- sModuleEMot
			),
		sortRefMaybe :Maude!Sort(
			name <- '@ReferenceMaybe',
			"module" <- sModuleEMot
			),
		sortRefSet :Maude!Sort(
			name <- '@ReferenceSet',
			"module" <- sModuleEMot
			),
		sortRefOrderedSet :Maude!Sort(
			name <- '@ReferenceOrderedSet',
			"module" <- sModuleEMot
			),
		sortRefBag :Maude!Sort(
			name <- '@ReferenceBag',
			"module" <- sModuleEMot
			),
		sortRefSequence :Maude!Sort(
			name <- '@ReferenceSequence',
			"module" <- sModuleEMot
			),
		sortOid : Maude!Sort(
			name <- 'Oid',
			"module" <- sModuleEMot
			),
		sortOidMaybe :Maude!Sort(
			name <- 'Maybe{Oid}',
			"module" <- sModuleEMot
			),
		sortOidSet :Maude!Sort(
			name <- 'Set{Oid}',
			"module" <- sModuleEMot
			),
		sortOidOrderedSet :Maude!Sort(
			name <- 'OrderedSet{Oid}',
			"module" <- sModuleEMot
			),
		sortOidBag :Maude!Sort(
			name <- 'Bag{Oid}',
			"module" <- sModuleEMot
			),
		sortOidSequence :Maude!Sort(
			name <- 'Sequence{Oid}',
			"module" <- sModuleEMot
			),
		sortSetObject : Maude!Sort(
			name <- 'Set{@Object}',
			"module" <- sModuleEMot
			),
		sfSort : Maude!Sort(
			name <- '@StructuralFeature',
			"module" <- sModuleEMot
			),
		sortStructFeat : Maude!Sort(
			name <- '@StructuralFeatureInstance',
			"module" <- sModuleEMot
			),
		sortSetSfi : Maude!Sort(
			name <- 'Set{@StructuralFeatureInstance}',
			"module" <- sModuleEMot
			),
		sortSetSf : Maude!Sort(
			name <- 'Set{@StructuralFeature}',
			"module" <- sModuleEMot
			),
		sortListOid : Maude!Sort(
			name <- 'List{Oid}',
			"module" <- sModuleEMot
			),
		stringSort : Maude!Sort(
			name <- 'String',
			"module" <- sModuleEMot 	
			),
		intSort : Maude!Sort(
			name <- 'Int',
			"module" <- sModuleEMot 	
			),
		enumSort : Maude!Sort(
			name <- 'Enum',
			"module" <- sModuleEMot	
			),
		boolSort : Maude!Sort(
			name <- 'Bool',
			"module" <- sModuleEMot 	
			),
		floatSort : Maude!Sort(
			name <- 'Float',
			"module" <- sModuleEMot 	
			),
		realSort : Maude!Sort(
			name <- 'Real',
			"module" <- sModuleEMot	
			),
		dataTypeInstanceSort : Maude!Sort(
			name <- '@DataTypeInstance',
			"module" <- sModuleEMot 	
			),
		-- Se usa para el trato especial de los enumerados, sobre los que no funciona eClass()
		enumLiteralSort : Maude!Sort(
			name <- 'EEnumLiteral@ecore',
			"module" <- sModuleEMot 	
			),
		sortCounter : Maude!Sort(
			name <- 'Counter@MGBehavior',
			"module" <- sModuleEMot
			),
		sortClock : Maude!Sort(
			name <- 'Clock@MGBehavior',
			"module" <- sModuleEMot
			),
		variableSort : Maude!Sort(
			name <- 'Variable@MGBehavior',
			"module" <- sModuleEMot
			),
		
		sortObjRole : Maude!Sort(
			name <- 'ObjectRole@Time',
			"module" <- sModuleEMot
			),
		sortAtActExec : Maude!Sort(
			name <- 'AtomicActionExec@MGBehavior',
			"module" <- sModuleEMot
			),
		atomicRuleSort : Maude!Sort(	
			name <- 'AtomicRule@MGBehavior',
			"module" <- sModuleEMot
			),
		sortNat : Maude!Sort(
			name <- 'Nat',
			"module" <- sModuleEMot
			),
		sortTime : Maude!Sort(
			name <- 'Time',
			"module" <- sModuleEMot
			),
		oclTypeSort : Maude!Sort(
			name <- 'OCL-Type',
			"module" <- sModuleEMot
			),
		oclExpSort : Maude!Sort(
			name <- 'OCL-Exp',
			"module" <- sModuleEMot
			),
		envSort : Maude!Sort(
			name <- 'Env',
			"module" <- sModuleEMot
			),
		vidSort : Maude!Sort(
			name <- 'Vid',
			"module" <- sModuleEMot
			),
		timeSort : Maude!Sort(
			name <- 'Time',
			"module" <- sModuleEMot
			),
		timeSort2 : Maude!Sort(
			name <- 'Time',
			"module" <- sModuleEMot
			),
		listSort : Maude!Sort(
			name <- 'List{OCL-Exp}',
			"module" <- sModuleEMot
			),
		listOrdSort : Maude!Sort(
			name <- 'ListOrd',
			"module" <- sModuleEMot
			),
		emptyListSort : Maude!Sort(
			name <- 'EmptyList',
			"module" <- sModuleEMot
			),
		varPairSort : Maude!Sort(
			name <- 'VarPair',
			"module" <- sModuleEMot
			),
		msgSort : Maude!Sort(
			name <- 'Msg',
			"module" <- sModuleEMot
			),
		emptySort : Maude!Sort(
			name <- 'Empty',
			"module" <- sModuleEMot
			),
		emptySetSort : Maude!Sort(
			name <- 'EmptySet',
			"module" <- sModuleEMot
			),
		setSort : Maude!Sort(
			name <- 'Set',
			"module" <- sModuleEMot
			),
		sequenceSort : Maude!Sort(
			name <- 'Sequence',
			"module" <- sModuleEMot	
			),
		bagSort : Maude!Sort(
			name <- 'Bag',
			"module" <- sModuleEMot	
			),
		orderedSetSort : Maude!Sort(
			name <- 'OrdSet', --en mOdCL se llama as� a la colecci�n OrderedSet
			"module" <- sModuleEMot	
			),
		mSetSort : Maude!Sort(
			name <- 'MSet{OCL-Exp}', --'MSet{X}',
			"module" <- sModuleEMot	
			),
		linkSort : Maude!Sort(
			name <- '@Link',
			"module" <- sModuleEMot
			),
		myLinkListSort : Maude!Sort(
			name <- 'MyLinkList',--equivale a 'ListOrd{@Link}',
			"module" <- sModuleEMot
			),
		opNameSort : Maude!Sort(
			name <- 'OpName',
			"module" <- sModuleEMot
			),
		nzTimeSort : Maude!Sort(
			name <- 'NzTime',
			"module" <- sModuleEMot
			),
		actExecSort : Maude!Sort(
			name <- 'ActionExec@MGBehavior',
			"module" <- sModuleEMot
			),
		actionStatusSort : Maude!Sort(
			name <- 'ActionStatus@MGBehavior',
			"module" <- sModuleEMot
			),
		itemListSort : Maude!Sort(
			name <- 'ItemList',
			"module" <- sModuleEMot
			),
		itemListOrdSort : Maude!Sort(
			name <- 'ItemListOrd',
			"module" <- sModuleEMot	
			),
		collectionSort : Maude!Sort(
			name <- 'Collection',
			"module" <- sModuleEMot
			),
		attributeSetSort : Maude!Sort(
			name <- 'AttributeSet',
			"module" <- sModuleEMot
			),
-----------------------------------------------------------
----------------------- Transf OCL ------------------------
-----------------------------------------------------------
		oclModule : Maude!SModule(
			name <- 'OCL'
			),
		auxiliaryModule : Maude!SModule(
			name <- 'MAUDELING'	
			),
		iterVarSort : Maude!Sort(
			name <- 'iter-vble',
			"module" <- auxiliaryModule
			),
		userOpNavSort : Maude!Sort(
			name <- 'UserOpNav',
			"module" <- auxiliaryModule	
			),
		oclAttrSort : Maude!Sort(
			name <- 'OCL-Attr',
			"module" <- auxiliaryModule	
			),
		attributeNameSort : Maude!Sort(
			name <- 'AttributeName',
			"module" <- auxiliaryModule	
			),
		letExpSort : Maude!Sort(
			name <- 'LetExp',
			"module" <- auxiliaryModule	
			),
		vbleDeclSort : Maude!Sort(
			name <- 'VbleDecl',
			"module" <- auxiliaryModule	
			),
		iterateExpSort : Maude!Sort(
			name <- 'iterate-exp',
			"module" <- auxiliaryModule	
			),
		attOpSort : Maude!Sort(
			name <- 'AttributeOp',
			"module" <- auxiliaryModule
			),
		ratSort : Maude!Sort(
			name <- 'Rat',
			"module" <- sModuleEMot
			)		
	do{
		thisModule.mSpec <- mSpec;
		thisModule.mainModule <- mainModule;
		thisModule.sModuleEMot <- sModuleEMot;
		thisModule.sortModel <- sortModel;
		thisModule.sortMetamodel <- sortMetamodel;
		thisModule.sortObject <- sortObject;
		thisModule.sortClock <- sortClock;
		thisModule.sortCounter <- sortCounter;
		thisModule.enumSort <- enumSort;	
		thisModule.sortSetObject <- sortSetObject;
		thisModule.sortStructFeat <- sortStructFeat;
		thisModule.sortSetSfi <- sortSetSfi;
		thisModule.sortSetSf <- sortSetSf;
		thisModule.sortListOid <- sortListOid;
		thisModule.sortAttribute <- sortAttribute;
		thisModule.sortRefSimple <- sortRefSimple;
		thisModule.sortRefInst <- sortRefInst;
		thisModule.sortAttInst <- sortAttInst;
		thisModule.sortRefMaybe <- sortRefMaybe;
		thisModule.sortRefSet <- sortRefSet;
		thisModule.sortRefOrderedSet <- sortRefOrderedSet;
		thisModule.sortRefSequence <- sortRefSequence;
		thisModule.sortRefBag <- sortRefBag;
		thisModule.sortOid <- sortOid;
		thisModule.sortOidMaybe <- sortOidMaybe;
		thisModule.sortOidSet <- sortOidSet;
		thisModule.sortOidOrderedSet <- sortOidOrderedSet;
		thisModule.sortOidSequence <- sortOidSequence;
		thisModule.sortOidBag <- sortOidBag;
		thisModule.stringSort <- stringSort;
		thisModule.intSort <- intSort;
		thisModule.boolSort <- boolSort;
		thisModule.floatSort <- floatSort;
		thisModule.realSort <- realSort;
		thisModule.dataTypeInstanceSort <- dataTypeInstanceSort;
		thisModule.enumLiteralSort <- enumLiteralSort;
		thisModule.sortNat <- sortNat;
		thisModule.sortObjRole <- sortObjRole;
		thisModule.sortAtActExec <- sortAtActExec;
		thisModule.oclTypeSort <- oclTypeSort;
		thisModule.oclExpSort <- oclExpSort;
		thisModule.varPairSort <- varPairSort;
		thisModule.vidSort <- vidSort;
		thisModule.timeSort <- timeSort;
		thisModule.timeSort2 <- timeSort2;
		thisModule.listSort <- listSort;
		thisModule.listOrdSort <- listOrdSort;
		thisModule.envSort <- envSort;
		thisModule.emptySort <- emptySort;
		thisModule.emptySetSort <- emptySetSort;
		thisModule.setSort <- setSort;
		thisModule.sequenceSort <- sequenceSort;
		thisModule.bagSort <- bagSort;
		thisModule.orderedSetSort <- orderedSetSort;
		thisModule.linkSort <- linkSort;
		thisModule.myLinkListSort <- myLinkListSort;
		thisModule.opNameSort <- opNameSort;
		thisModule.variableSort <- variableSort;
		thisModule.nzTimeSort <- nzTimeSort;
		thisModule.actExecSort <- actExecSort;
		thisModule.itemListSort <- itemListSort;
		thisModule.itemListOrdSort <- itemListOrdSort;
		thisModule.collectionSort <- collectionSort;
		thisModule.letExpSort <- letExpSort;
		thisModule.vbleDeclSort <- vbleDeclSort;
		thisModule.iterateExpSort <- iterateExpSort;
		thisModule.oclModule <- oclModule;
		thisModule.auxiliaryModule <- auxiliaryModule;
		thisModule.userOpNavSort <- userOpNavSort;
		thisModule.iterVarSort <- iterVarSort;
		thisModule.oclAttrSort <- oclAttrSort;
		thisModule.attributeNameSort <- attributeNameSort;
		thisModule.attOpSort <- attOpSort;
		thisModule.ratSort <- ratSort;
		thisModule.sfSort <- sfSort;		
		thisModule.attributeSetSort <- attributeSetSort;
		thisModule.emptyListSort <- emptyListSort;
		thisModule.msgSort <- msgSort;
		thisModule.actionStatusSort <- actionStatusSort;
		thisModule.atomicRuleSort <- atomicRuleSort;
		thisModule.mSetSort <- mSetSort;
		
		for(i in thisModule.allStructuralFeatures){
			thisModule.CreateAttributeOp(i);
		}
		for (j in thisModule.allBehaviorElements->first().metamodelGD){
			thisModule.CreateModule(j.name);
		}	
		thisModule.RulesInformation();		
	}
}
--Esta regla va a crear una operaci�n y una ecuaci�n para cada atributo del metamodelo (ejemplo: op xPos@Antenna@MPNs : -> AttributeOp .)
--Hay que crearlos porque mOdCL lo necesita para navegar por ellos
lazy rule CreateAttributeOp{
	from
		sf : Behavior!EStructuralFeature
	to
		oper : Maude!Operation(
			name <- sf.name.processSpecOpChars()+'@OCLSf',
			coarity <- thisModule.sfSort,					
			"module" <- thisModule.mainModule
			),
		eq : Maude!Equation(
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			"module" <- thisModule.mainModule
			),
		lhsTerm : Maude!RecTerm(
			op <- 'name',
			type <- thisModule.stringSort,
			args <- nameArg
			),
		nameArg : Maude!Constant(
			op <- sf.name.processSpecOpChars()+'@OCLSf',
			type <- sf.slotType()					
			),
		rhsTerm : Maude!Constant(
			op <- '"'+sf.name+'"',
			type <- thisModule.stringSort
			)
}

lazy rule CreateModule{
	from
		mm : String
	to
		mImportMM : Maude!ModImportation(
			mode <- #protecting,
			imports <- moduleIdModExpMM
			),
		moduleIdModExpMM : Maude!ModuleIdModExp(
			"module" <- sModuleMM
			),
		sModuleMM : Maude!SModule(
			name <- mm.processSpecModChars().processSpecOpChars()
			)
	do{
		thisModule.mainModule.els <- thisModule.mainModule.els->append(mImportMM);
	}
}

rule RulesInformation(){
	to
		eq : Maude!Equation(
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			"module" <- thisModule.mainModule
			),
		lhsTerm : Maude!Constant(
			op <- 'rulesInformation',
			type <- thisModule.sortModel
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- if thisModule.allAtomicRules->isEmpty() then 
						Sequence{mm,thisModule.CreateConstant('none',thisModule.sortSetObject)}
					else
						if thisModule.allAtomicRules->size()=1 then
							Sequence{mm,thisModule.ObjectSimple(thisModule.allAtomicRules->first(),1)}
						else
							Sequence{mm,thisModule.ObjectList(thisModule.allAtomicRules)}
						endif
					endif
		),
		mm : Maude!Constant(
			op <- '@MGBehavior@',
			type <- thisModule.sortModel
		)
}

lazy rule ObjectSimple{
	from
		rl : Behavior!AtomicRule,
		num : Integer
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{id,type,feats}
			),
		id : Maude!Variable(
			name <- '\'Rule'+num.toString(),
			type <- thisModule.oclTypeSort
			),
		type : Maude!Constant(
			op <- 'AtomicRule@MGBehavior',
			type <- thisModule.atomicRuleSort
			),
		feats : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_#_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{name,lbound,ubound,soft,period}
			),
		name : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortAttInst,
			args <- Sequence{nameLeft,nameRight}
			),
		nameLeft : Maude!Constant(
			op <- 'name@Rule@MGBehavior',
			type <- thisModule.sortAttribute
			),
		nameRight : Maude!Constant(
			op <- '"'+rl.name+'"',
			type <- thisModule.oclTypeSort
			),
		lbound : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortAttInst,
			args <- if (rl.lowerBound.oclIsUndefined() or rl.lowerBound <= 0.0) then Sequence{lboundLeft,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}
					else Sequence{lboundLeft,thisModule.ConvertToRat(rl.lowerBound.toString())}
					endif
			),
		lboundLeft : Maude!Constant(
			op <- 'lowerBound@Rule@MGBehavior',
			type <- thisModule.sortAttribute
			),
		ubound : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortAttInst,
			args <- if (rl.upperBound.oclIsUndefined() or rl.upperBound = -1.0) then Sequence{uboundLeft,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}
					else Sequence{uboundLeft,thisModule.ConvertToRat(rl.upperBound.toString())}
					endif
			),
		uboundLeft : Maude!Constant(
			op <- 'upperBound@Rule@MGBehavior',
			type <- thisModule.sortAttribute
			),
		soft : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortAttInst,
			args <- Sequence{softLeft,softRight}
			),
		softLeft : Maude!Constant(
			op <- 'soft@Rule@MGBehavior',
			type <- thisModule.sortAttribute
			),
		softRight : Maude!Constant(
			op <- rl.soft.toString(),
			type <- thisModule.oclTypeSort
			),	
			
		period : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortAttInst,
			args <- if (rl.periodicity.oclIsUndefined() or rl.periodicity <= 0.0) then Sequence{periodLeft,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}
					else Sequence{periodLeft,thisModule.ConvertToRat(rl.periodicity.toString())}
					endif
			),
		periodLeft : Maude!Constant(
			op <- 'periodicity@AtomicRule@MGBehavior',
			type <- thisModule.sortAttribute
			)
}

lazy rule ObjectList{
	from
		allRules : Sequence(Behavior!AtomicRule)
	to
		objSet : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- Sequence{}
			)
	do{		
		for (i in allRules){
			thisModule.counterRules <- thisModule.counterRules + 1;
			objSet.args <- objSet.args -> append(thisModule.ObjectSimple(i,thisModule.counter));
		}
		thisModule.counterRules <- 0;
	}
}

lazy rule ConvertToRat{
  from
    num : String
  to
	tr : Maude!RecTerm(
	  op <- thisModule.toRatOperator,
	  type <- thisModule.ratSort,
	  args <- argNum  
	),
	argNum : Maude!Constant(
	  op <- num,
	  type <- thisModule.oclTypeSort
	)	
}

---------------------------------------------------------------------------------------------------------------------------
--Por cada ATOMIC RULE de Behavior se crean 2 CONDITIONAL RULEs en Maude TRIGGERING y REALIZATION
--En una ATOMIC RULE cuando se cumple la precondicion (cocurrencia de LHS y no ocurrencia de NACs)
--la accion se programa para aplicarse tras t unidades de tiempo (duracion de la accion modelada por la regla)
--En ese momento la regla se aplica computando los atributos y sustituyendo el estado del sistema por el indicado en RHS

--Cada regla va a ser de la forma l:[NAC]xLHS->RHS donde l es el nombre de la regla, LHS y RHS son modelos que
--representan estados del sistema y NAC es un conjunto de condiciones opcionales, si alguna de estas condiciones se cumple
--para el modelo se prohibe la aplicacion de la regla
--LHS y NACs representan la precondicion para que se ejecute la regla (TRIGGERING RULE)
--RHS representan la ejecuci�n de la acci�n (REALIZATION RULE) y se producir� si la precondici�n se cumple
rule AtomicRule2Rule{  
	from
		rl : Behavior!AtomicRule (not (rl.minDuration.oclIsUndefined() or rl.minDuration='') and rl.minDuration <> '0')
	to
		------------------------------------------------------------------	
		-----------------------TRIGGERING RULE----------------------------
		------------------------------------------------------------------
		--Cuando la precondici�n de una regla se satisface se crea un objeto 'AtomicActionExec'. Estos objetos representan
		--la ejecucion de Atomic Rules. Cada uno actua como una cuenta atras hasta la finalizacion de la regla.
		crlpre : Maude!Rule( 		
			"module" <- thisModule.mainModule,
			label <- rl.name.processSpecOpChars() + '@Triggering',
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			--Se computan los atributos, las variables y las referencias y se a�aden las diferentes condiciones que estar�n presentes
			--en TODAS las AtomicRules
			conds <- Sequence{thisModule.TimerCond(''),thisModule.lhsCond(rl)}->
						union(rl.vbles -> collect(s|thisModule.VarComputation(s))) ->
						union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t))) ->
						union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->
						append(thisModule.MinDurationComputation(rl)) ->
						--append(thisModule.MaxDurationComputation(rl)) ->
						--Hay que poner estas condiciones en la parte imperativa porque necesito que aparezcan en lugares concretos
						--en el archivo maude de salida
						--union(rl.vbles -> collect(s|thisModule.VarComputation(s))) ->
						--union(rl.nacs -> collect(o|thisModule.NacsCond(o))) ->
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))	
			),
			
		--------------- lhs(Maude) de la TRIGGERING RULE (representa el modelo) -----------------------	
		lhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),					
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- --Elementos del patr�n LHS. Es necesario diferenciar entre elementos ActionExec y elementos Object
					--habr� que llamar a una/s determinadas reglas para tipo de elemento. Siempre habr� que crear los elementos COUNTER, CLOCK y OBJSET
					--Estos if anidados son utilizados m�s adelante. Se pens� implementarlos en un helper pero las llamadas dentro
					--de cada if son diferentes y adem�s los elementos que devuelven son diferentes. Podr�a implementarse un helper para cada caso
					--pero la longitud del codigo ser�a la misma.					
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}					
			),		
		-----------------------------------FIN  lhs(Maude) de la Triggering rule------------------------------------------
		----------------------------------- rhs(Maude) de la Triggering rule ---------------------------------------------
		---- Aqu� se va a programar la accion especificada por la regla una vez que se produzca una ocurrencia de LHS
		---- y una no ocurrencia de NAC
		---- El contador se actualiza con el numero de Object Role + Variables + 1
		---- Action Execution representa el disparador (triggering) de la regla.
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mmrhs,rhsTermArgs}
			),
		mmrhs : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),				
		rhsTermArgs : Maude!RecTerm( --Cuidado: Aqu� estamos haciendo rhs de Maude, PERO LHS de Behavior
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <-
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimer(rl),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(rl.objActExecLHSRule()->size()+rl.vbles->size()+1),
					thisModule.CreateRandomCounter(true),thisModule.CreateOBJSET('')
					}
				),		
		
		--------------------FIN rhs(Maude) de la TRIGGERING rule-------------
		
		--------------------------------------------------------------------- 
		-------------------------- FIN TRIGGERING RULE ----------------------
		---------------------------------------------------------------------
		
		
		
		----------------------------------------------------------------------
		-------------------------------REALIZATION RULE-----------------------
		----------------------------------------------------------------------
		--Una vez el timer de la regla es 0, la correspondiente accion puede ser representada si ninguno de los 
		--participantes en la accion ha sido borrado. El patr�n LHS ser� sustituido por el RHS y los valores
		--de los atributos seran computados
		
		crlpost : Maude!Rule(
			"module" <- thisModule.mainModule,
			label <- rl.name.processSpecOpChars() + '@Realization',
			lhs <- lhsTermPost,			
			rhs <- rhsTermReadjust,			
			conds <- Sequence{thisModule.lhsCondRealization(rl)} -- ->
--					union(rl.NewObjectsInRhs()->collect(i|thisModule.CreateElementCond(i))) ->
--					union(rl.NACSRule() -> collect(o|thisModule.NacsCond(rl)))
			),
			
		-----------------------------lhs(Maude) de la REALIZATION RULE-----------------------------------------------
		lhsTermPost : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mmPost,lhsTermArgsPost}
			),
		mmPost : Maude!Variable( 
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),				
		lhsTermArgsPost : Maude!RecTerm(
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <- 				
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermRealization(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimerRealization(rl,false),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}					
			),
		-------------------------FIN lhs(Maude) de la REALIZATION RULE------------------------------ 
		
		
		------------------------ rhs(Maude) de la REALIZATION RULE----------------------------------
		--Aqu� se sustituye el patr�n LHS por el RHS. Se van a incluir las computaciones de atributos (slots) y los
		--links creados (manejados mediante la operacion addRef)
		
		--La operaci�n readjust tiene tres argumentos:
		--El primero tiene el conjunto de elementos (objetos y action execution) borrados
		--El segundo tiene el conjunto de links borrados
		--El modelo: los objetos de RHS, el timer, el clock, el counter y ORs
		rhsTermReadjust : Maude!RecTerm(
			op <- thisModule.readjustOp,
			type <- thisModule.sortModel, 
			args <- --Sequence{idAction,deletedEl,rhsTermPost}
--					if rl.deletedLinks() -> isEmpty() then Sequence{idAction,deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),rhsTermPost}
--					else
--						if rl.deletedLinks() -> size()=1 then Sequence{idAction,deletedEl,thisModule.LinkSimple(rl.deletedLinks()->first()),rhsTermPost}
--						else Sequence{idAction,deletedEl,thisModule.LinkList(rl.deletedLinks()),rhsTermPost}
--						endif
--					endif
					if rl.SlotsOfReferences()->isEmpty() then Sequence{idAction,deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),rhsTermPost}
					else
						if rl.SlotsOfReferences()->size()=1 then Sequence{idAction,deletedEl,thisModule.SlotRefSimple(rl.SlotsOfReferences()->first()),rhsTermPost}
						else Sequence{idAction,deletedEl,thisModule.SlotRefList(rl.SlotsOfReferences()),rhsTermPost}
						endif
					endif
			),
		idAction : Maude!Variable(
			name <- 'ACTEXEC@',  --'TIMER@',
			type <- thisModule.sortOid
			),
		deletedEl : Maude!RecTerm( --se crea el contenedor Set_ para el conjunto de elementos borrados
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsDeleted
			args <- if rl.deletedObjects() -> isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.deletedObjects()->size()=1 then thisModule.PatternElDeleted(rl.deletedObjects()->first())
						else thisModule.PatternElDeletedMany(rl.deletedObjects())							
						endif
					endif
			),
			
			
		rhsTermPost : Maude!RecTerm(
			op <- thisModule.modelOperator,
			type <- thisModule.sortModel, 
			args <- Sequence{mmrhsPost,rhsTermArgsPost}
			),
		mmrhsPost : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		rhsTermArgsPost : Maude!RecTerm(   --Cuidado: Aqu� estamos haciendo rhs de Maude, PERO RHS de Behavior
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 		
					Sequence{
					rl.objActExecRHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then rl.ObjectRHS2RecTerm(i)		
													else thisModule.ActEx2RecTerm(i,true)
													endif),					
					--thisModule.CreateTimerRealization(rl,true),
					thisModule.CreateClock(rl.rhs),
					--thisModule.CreateCounter(rl.numObjInRhs()),
					--thisModule.CreateCounter(rl.numObjInRhsAux()),
					thisModule.CreateRandomCounter(true),thisModule.CreateOBJSET('')
					}
					->union(if rl.periodicity > 0.0 and rl.soft then Sequence{thisModule.CreateTimerRealization(rl,true),thisModule.CreateCounter(rl.numObjInRhs())}
							else Sequence{thisModule.CreateCounter(rl.numObjInRhsAux())}
							endif)
					--se a�aden tambi�n los elementos borrados (elementos de lhs que no aparecen en RHS) que ser�n manejados de una forma especial
					->union(rl.deletedElements()->collect(i|if i.oclIsTypeOf(Behavior!Object) then																
																thisModule.Object2RecTermRealization(i,rl.lhs)
															else															
																thisModule.ActExInterrupted2RecTerm(i)
															endif)
															)			
			)
		
		----------------------------- FIN rhs(Maude) de la REALIZATION rule ----------------------------------------------------
		
		--------------------------------------------------------------------------
		-----------------------------FIN REALIZATION RULE-------------------------
		--------------------------------------------------------------------------
		
	
	do{	
		--El for sirve para crear los ORi y sus condiciones. Los creo en la parte imperativa porque
		--en principio no se cuantos objetos tiene el modelo por lo que tendr� que usar un for para numerar los ORi
		--Lo mismo ocurre con los objetos VARi y sus condiciones
		--ES IMPORTANTE EL ORDEN EN QUE ESTAN COLOCADOS LOS BUCLES FOR PUESTO QUE ALGUNOS UTILIZAN LA VARIABLE CONTADOR DE
		--BUCLES ANTERIORES
		--for (p in rl.objectsLHSRule()){
		for (p in rl.objActExecLHSRule()){			
			thisModule.counter <- thisModule.counter +1;
			rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			lhsTermArgsPost.args <- lhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			if (rl.periodicity > 0.0 and rl.soft){
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			}
			--crlpre.conds <- crlpre.conds -> union(Sequence{thisModule.CondOR(thisModule.counter,thisModule.counter)});
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondOR(thisModule.counter,thisModule.counter));
		}
		thisModule.counterRhs <- thisModule.counter;		
		thisModule.counter <- thisModule.counter +1;
		for (p in rl.vbles){
			thisModule.counterV <- thisModule.counterV +1;
			--crlpre.conds <- crlpre.conds -> union(Sequence{thisModule.CondVAR(thisModule.counterV,thisModule.counter)});
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}		
		thisModule.counterV <- 0;
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				lhsTermArgsPost.args <- lhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;
		thisModule.counter <- 0;
			
		--Para los ORi de la parte derecha y sus condiciones en la realization rule
		--for (p in rl.NewObjectsRHS()){
		if (rl.periodicity > 0.0 and rl.soft){
			for (p in rl.NewObjActExecRHS()){			
				thisModule.counterRhs <- thisModule.counterRhs + 1;
				--crlpost.conds <- crlpost.conds -> prepend(thisModule.CondOR(thisModule.counterRhs,thisModule.newCounter));
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counterRhs)});
				thisModule.newCounter <- thisModule.newCounter + 1;
			}
		}
		--for (p in rl.NewObjectsRHS()){
		for (p in rl.NewObjActExecRHS()){	
			crlpost.conds <- crlpost.conds -> prepend(thisModule.CondInitializeVar(p.id,thisModule.newCounter));
			thisModule.newCounter <- thisModule.newCounter + 1;
		}
		
		for (p in rl.rhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--crlpost.conds <- crlpost.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.newCounter));
			}
			thisModule.countORAE <- 0;
		}
		
		for(r in rl.deletedElements()->select(i|i.oclIsTypeOf(Behavior!ActionExec))){
			for (q in r.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
			}
			thisModule.countORAE <- 0;
		}		
		
		
		--Para crear las VARi@
		for (p in rl.vbles){
			thisModule.counterVar <- thisModule.counterVar +1;
			rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
			lhsTermArgsPost.args <- lhsTermArgsPost.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
			if (rl.periodicity > 0.0 and rl.soft){
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
			}
		}
		thisModule.counterVar <- 0;
		thisModule.countORAE <- 0;
		thisModule.counterRhs <- 0;
		thisModule.newCounter <- 0;
		
-----------CONDICIONES QUE ESTARAN PRESENTES SEGUN LAS CARACTERISTICAS CONCRETAS DE LA REGLA---------------------------------

--Problema: las condiciones lowerbound y upperbound funcionan pero si al editar el modelo se seleccionan las propiedades
--ya no se detectan vac�as aunque las dejemos en blanco
--Soluci�n: En una versi�n posterior las propiedades upperBound y lowerBound pasaron a ser de tipo EFloat con valores por defecto
--de -1.0 y 0.0 respectivamente. Al tener un valor pr defecto ya no se detecta el problema anterior.
		
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.LowerBoundCondition(rl));
		}

		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			crlpre.conds <- crlpre.conds -> append(thisModule.UpperBoundCondition(rl));
		}
		
		---PARA PERIODIC RULES: se introduce la condici�n 'inPeriod'
		
--		if ((rl.oclIsTypeOf(Behavior!AtomicRule)) and (rl.periodicity > 0.0)){
--			crlpre.conds <- crlpre.conds -> append(thisModule.inPeriodCondition(rl));
--		}
		
		--Para reglas que NO sean "SOFT PERIODIC" se incluye la operaci�n 'multiple'
		--Si la regla fuera SOFT PERIODIC s incluir�a (en lugar de la operaci�n 'multiple') la condici�n alreadyExecInPeriod
--		if (rl.periodicity > 0.0){
--			if (rl.soft){   --and rl.periodicity <> -1.0 ){
--				crlpre.conds <- crlpre.conds -> append(thisModule.AlreadyCondition(rl));
--				thisModule.AlreadyOpEq(rl);
--			}
--			else{
--				crlpre.conds <- crlpre.conds -> append(thisModule.multipleCondition(rl));
--			}
--		}
        
		if (rl.periodicity > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.AlreadyCondition(rl));
			thisModule.AlreadyOpEq(rl);					
			if (not rl.soft){
				crlpre.conds <- crlpre.conds -> append(thisModule.multipleCondition(rl));
			}
		}
			
			
		if ((not rl.maxDuration.oclIsUndefined()) and rl.maxDuration<>''){
			crlpre.conds <- crlpre.conds -> append(thisModule.MaxDurationComputation(rl));
		}	
		
-----------------------------------------------------------------------------------------------------------------------		
		
		
		--Si la regla tiene asociados patrones NAC se llama a una regla espec�fica para crear la operaci�n y las ecuaciones 
		--de dicho NAC
		
		for (p in rl.nacs){
			thisModule.OperationNac(p);
		}
		
		--La operaci�n CURRENT EXEC sirve para evitar un numero indefinido de ejecuciones de la regla. Esta llamada a una lazy rule
		--crear� dicha operaci�n y sus ecuaciones
		if (rl.periodicity = 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.CurrentExecCondition(rl));
			thisModule.CurrentExecOp(rl);
		}
		
		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			crlpre.conds <- crlpre.conds -> append(thisModule.DpoCondition(rl));
			}
		}
		
		----La ecuaci�n mte se define para EAGER RULES. Dichas reglas se ejecutan tan pronto como es posible.
		if (not((rl.soft) and not(rl.periodicity > 0.0 ))){			
			thisModule.mte(rl);
		}
		
--�������ESTO ESTA AQUI PARA HACER LAS PRUEBAS CON EL EJEMPLO DEL MOVIL PARA HACER QUE EL MOVIL!!!!!! 
--�������SE ENCIENDA OBLIGATORIAMENTE EN CUANTO PUEDA!!!!!!!!
--������HAY QUE ELIMINARLA!!!!!!!
--		if (rl.name='SwitchOn'){
--			thisModule.mte(rl);
--		}
		
		-- Esta condici�n puede crearse dentro de la parte declarativa de la regla. Se va a crear aqu� porque en el caso de que haya variables
		-- vamos a necesitar que esta condici�n aparezca despues de la inicializaci�n de variables por ello la generamos despu�s.
		-- Se intent� insertar la condici�n de inicializaci�n antes en la secuencia mediante los comandos "prepend" y "insertAt"
		-- pero no funcionan correctamente
		crlpre.conds <- crlpre.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));
	}
}
		
		
		


rule OngoingRule2Rule{
	from
		rl : Behavior!OngoingRule
	to
		------------------------------------------------------------------	
		-----------------------TRIGGERING RULE--------------------------
		------------------------------------------------------------------
		crlpre : Maude!Rule( 		
			"module" <- thisModule.mainModule,
			label <- rl.name.processSpecOpChars() + '@Triggering',
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			conds <- Sequence{thisModule.TimerCond(''),thisModule.lhsCond(rl)}  ->
						union(rl.vbles -> collect(s|thisModule.VarFreeze(s)))  ->
						append(thisModule.CurrentExecCondition(rl)) ->
						union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t)))  ->
						union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))

			),
			
		---------------------------------------------- lhs(Maude) de la Triggering rule	
		lhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),					
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),thisModule.CreateCounter(0),
					thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}				
				),					
		--------------------------------------------FIN  lhs(Maude) de la Triggering rule
		
		-------------------------------------------- rhs(Maude) de la Triggering rule 
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mmrhs,rhsTermArgs}
			),
		mmrhs : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),				
		rhsTermArgs : Maude!RecTerm(--Cuidado: Aqu� estamos haciendo rhs de Maude, PERO LHS de BEhavior
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimerOngoing(rl),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(rl.objActExecLHSRule()->size()+rl.vbles->size()+1),
					thisModule.CreateRandomCounter(true),thisModule.CreateOBJSET('')
					}	
				)				
		-----------------------------------------------FIN rhs(Maude) de la TRIGGERING rule
	do{		
		for (p in rl.objActExecLHSRule()){
			thisModule.counter <- thisModule.counter +1;
			rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			--lhsTermArgsPost.args <- lhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			--crlpre.conds <- crlpre.conds -> union(Sequence{thisModule.CondOR(thisModule.counter,thisModule.counter)});
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondOR(thisModule.counter,thisModule.counter));
		}
		thisModule.counter <- thisModule.counter +1;
		for (p in rl.vbles){
			thisModule.counterV <- thisModule.counterV +1;
			--crlpre.conds <- crlpre.conds -> union(Sequence{thisModule.CondVAR(thisModule.counterV,thisModule.counter)});
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}
		thisModule.counter <- 0;
		thisModule.counterV <- 0;
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--lhsTermArgsPost.args <- lhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
			}
			thisModule.countORAE <- 0;
		}		
		thisModule.countORAE <- 0;
		
		for (p in rl.vbles){
			thisModule.counterVar <- thisModule.counterVar +1;
			--rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
			rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateFreezeVarOngoing(p,thisModule.counterVar)});
		}
		thisModule.counterVar <- 0;
		
		--if (not rl.lowerBound.oclIsUndefined() and ( rl.lowerBound.toString() <> '')){
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.LowerBoundCondition(rl));
		}
		
		--if (not rl.upperBound.oclIsUndefined() and ( rl.upperBound.toString() <> '')) {
		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			crlpre.conds <- crlpre.conds -> append(thisModule.UpperBoundCondition(rl));
		}
		
		---currentExec@RuleName
		thisModule.CurrentExecOp(rl);
		
		
		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			crlpre.conds <- crlpre.conds -> append(thisModule.DpoCondition(rl));
			}
		}
		
		
-------Operation asociadas a las condiciones-------		
		for (p in rl.nacs){
			thisModule.OperationNac(p);
		}		
------- mte ----------------------------
		if (not rl.soft){ 	
			thisModule.mte(rl);
		}
--------------------------------

		crlpre.conds <- crlpre.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));

--------------------------------

		if (not(rl.maxDuration.oclIsUndefined() or rl.maxDuration='')){
			crlpre.conds <- crlpre.conds -> append(thisModule.MaxDurationOngoingComputation(rl,false));
		}

----------apply@OngoingRule
		thisModule.ApplyOngoingRules(rl);
------------------------------
		
	}
}

		






--Sirve para determinar si un objeto de RHS se va a crear como nuevo o estaba incluido en LHS
helper context Behavior!Rule def : ObjectRHS2RecTermApplyOngoing(obj : Behavior!Object) : Maude!RecTerm =
	if self.NewObjectsRHS()->includes(obj) then thisModule.NewObjectRHS2RecTerm(obj,self.rhs)
	else thisModule.Object2RecTermApplyOngoingRHS(obj,self.rhs)
	endif;


---Conditional Equation: applyOngoingRule-----------------
lazy rule ApplyOngoingRules{
	from
		rl : Behavior!OngoingRule
	to
		eq : Maude!Equation(
			"module" <- thisModule.mainModule,
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			conds <-Sequence{thisModule.lhsCondApplyOngoing(rl)}->  --,thisModule.CurrentExecCondition(rl)} ->
						union(rl.vbles -> collect(s|thisModule.FreezeVarComputation(s)))  ->
						union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t)))->
						union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->															
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))						
			),
		lhsTerm : Maude!RecTerm(
			op <- 'applyOngoingRules',
			type <- thisModule.oclExpSort,
			args <- Sequence{lhsT,tVar}
			),			
		lhsT : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel, -- thisModule.intSort
			args <- Sequence{mm,lhsTermArgs} --set}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),			
		tVar : Maude!Variable(
			name <- 'T',
			type <- thisModule.oclTypeSort --thisModule.timeInfSort
			),
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermApplyOngoingLHS(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimerRealization(rl,false),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}			
			),			
					
	----------------------- rhs ---------------------------------------------------------				
		rhsTerm : Maude!RecTerm(
			op <- 'applyOngoingRules',
			type <- thisModule.oclExpSort,
			args <- Sequence{rhsTermReadjust,tVarRhs} --setRhs
			),			
		tVarRhs : Maude!Variable(
			name <- 'T',
			type <- thisModule.oclTypeSort --thisModule.timeInfSort
			),	
		rhsTermReadjust : Maude!RecTerm(
			op <- thisModule.readjustOp,
			type <- thisModule.oclExpSort,
			args <- --Sequence{deletedEl,rhsTermPost}
--					if rl.deletedLinks() -> isEmpty() then 
--						Sequence{deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),rhsTermPost}
--					else
--						if rl.deletedLinks() -> size()=1 then 
--							Sequence{deletedEl,thisModule.LinkSimple(rl.deletedLinks()->first()),rhsTermPost}
--						else
--							Sequence{deletedEl,thisModule.LinkList(rl.deletedLinks()),rhsTermPost}
--						endif
--					endif
					if rl.SlotsOfReferences()->isEmpty() then Sequence{deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),rhsTermPost}
					else
						if rl.SlotsOfReferences()->size()=1 then Sequence{deletedEl,thisModule.SlotRefSimple(rl.SlotsOfReferences()->first()),rhsTermPost}
						else Sequence{deletedEl,thisModule.SlotRefList(rl.SlotsOfReferences()),rhsTermPost}
						endif
					endif
			),
		deletedEl : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			args <- if rl.deletedObjects() -> isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.deletedObjects()->size()=1 then thisModule.PatternElDeleted(rl.deletedObjects()->first())
						else
							thisModule.PatternElDeletedMany(rl.deletedObjects())							
						endif
					endif
			),						
				
			
		rhsTermPost : Maude!RecTerm(
			op <- thisModule.modelOperator,
			type <- thisModule.sortModel, 
			args <- Sequence{mmrhsPost,rhsTermArgsPost}
			),
		mmrhsPost : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		rhsTermArgsPost : Maude!RecTerm(   --Cuidado: Aqu� estamos haciendo rhs de Maude, PERO RHS de Behavior
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecRHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then rl.ObjectRHS2RecTermApplyOngoing(i)		
													else thisModule.ActEx2RecTerm(i,true)
													endif),
					--thisModule.CreateTimerRealization(rl,true),
					thisModule.CreateClock(rl.rhs),
					--thisModule.CreateCounter(rl.numObjInRhs()),
					thisModule.CreateCounter(rl.numObjInRhsAux()),
					thisModule.CreateRandomCounter(true),thisModule.CreateOBJSET('')
					}	
					--se a�aden tambi�n los elementos borrados (elementos de lhs que no aparecen en RHS) que ser�n manejados de una forma especial
					->union(rl.deletedElements()->collect(i|if i.oclIsTypeOf(Behavior!Object) then
																thisModule.Object2RecTerm(i,rl.lhs)																
															else
																--thisModule.ActEx2RecTerm(i)
																thisModule.ActExInterrupted2RecTerm(i)
															endif)
															)			
			)			
				
	do{		
		for (p in rl.objActExecLHSRule()){
			thisModule.counter <- thisModule.counter +1;			
			lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			--rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
		}
		thisModule.counterRhs <- thisModule.counter;
		thisModule.counter <- thisModule.counter +1;		
		for (p in rl.vbles){
			thisModule.counterVar <- thisModule.counterVar +1;
			lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateFreezeVarApply(p,thisModule.counterVar)});
			--rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateFreezeVarApply(p,thisModule.counterVar)});			
			--eq.conds <- eq.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}
		--thisModule.counter <- 0;
		thisModule.counterVar <- 0;		
		
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;		
			
--		for (p in rl.NewObjActExecRHS()){
--			thisModule.counterRhs <- thisModule.counterRhs + 1;			
--			eq.conds <- eq.conds -> prepend(thisModule.CondOR(thisModule.counterRhs,thisModule.newcounter));
--			rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counterRhs)});
--			thisModule.newCounter <- thisModule.newCounter + 1;
--		}
--
		for (p in rl.NewObjActExecRHS()){
			eq.conds <- eq.conds -> prepend(thisModule.CondInitializeVar(p.id,thisModule.newCounter));
			thisModule.newCounter <- thisModule.newCounter + 1;
		}
		thisModule.counter <- 0;
		thisModule.counterRhs <- 0;
		thisModule.newCounter <- 0;
		
		for (p in rl.rhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
			}
			thisModule.countORAE <- 0;
		}
		
		for(r in rl.deletedElements()->select(i|i.oclIsTypeOf(Behavior!ActionExec))){
			for (q in r.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
			}
			thisModule.countORAE <- 0;
		}			
		

	
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			eq.conds <- eq.conds -> append(thisModule.LowerBoundCondition(rl));
		}
		
		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			eq.conds <- eq.conds -> append(thisModule.UpperBoundCondition(rl));
		}
		
		eq.conds <- eq.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));
		
		if (not(rl.maxDuration.oclIsUndefined() or rl.maxDuration='')){
			eq.conds <- eq.conds -> append(thisModule.MaxDurationOngoingComputation(rl,true));
		}
		
		
		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			eq.conds <- eq.conds -> append(thisModule.DpoCondition(rl));
			}
		}
		
		
	}
}

--Sirve para determinar si un objeto de RHS se va a crear como nuevo o estaba incluido en LHS
helper context Behavior!Rule def : ObjectRHS2RecTerm(obj : Behavior!Object) : Maude!RecTerm =
	if self.NewObjectsRHS()->includes(obj) then thisModule.NewObjectRHS2RecTerm(obj,self.rhs)
	else thisModule.Object2RecTerm(obj,self.rhs)
	endif;
		
		
--Las reglas instantaneas son las ATOMIC RULES cuyo atributo DURATION vale 0.
--En este caso habr� una sola regla
rule InmediateAtomicRules{
	from
		rl :Behavior!AtomicRule (not(rl.minDuration.oclIsUndefined() or rl.minDuration='') and rl.minDuration = '0')
	to		
		crlpre : Maude!Rule( 		
			"module" <- thisModule.mainModule,
			label <- rl.name.processSpecOpChars() + '@Instantaneous',
			lhs <- lhsTerm,
			rhs <- rhsTermReadjust,
			--Aqu� se llaman a las lazy rules que a�adir�n las condiciones de la Regla.
			--Se computan los atributos, las variables y las referencias y se a�aden las diferentes condiciones
			conds <- Sequence{thisModule.TimerCond(''),thisModule.LhsCondInstantaneous(rl)}	->	--,thisModule.CurrentExecCondition(rl)} ->
						union(rl.vbles -> collect(s|thisModule.VarComputation(s))) ->
						union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t))) ->
						union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->
						--append(thisModule.MinDurationComputation(rl)) ->
						append(thisModule.ExecutionTimeComputation('')) ->
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))							
			),
			
		--------------- lhs(Maude) de la INSTANTANEOUS RULE (representa el modelo) -----------------------	
		lhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( 
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),					
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermApplyOngoingLHS(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),thisModule.CreateCounter(0),
					thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}			
				),

		
		--------------------FIN lhs(Maude) de la INSTANTANEOUS rule-------------

		
		--------------------rhs(Maude) de la INSTANTANEOUS RULE-----------------------------------------------
		rhsTermReadjust : Maude!RecTerm(
			op <- thisModule.readjustOp,
			type <- thisModule.sortModel, 
			args <- --Sequence{deletedEl,rhsTermPost}
--					if rl.deletedLinks() -> isEmpty() then Sequence{deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),rhsTermPost}
--					else
--						if rl.deletedLinks() -> size()=1 then Sequence{deletedEl,thisModule.LinkSimple(rl.deletedLinks()->first()),rhsTermPost}
--						else Sequence{deletedEl,thisModule.LinkList(rl.deletedLinks()),rhsTermPost}
--						endif
--					endif
					if rl.SlotsOfReferences()->isEmpty() then Sequence{deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),rhsTermPost}
					else
						if rl.SlotsOfReferences()->size()=1 then Sequence{deletedEl,thisModule.SlotRefSimple(rl.SlotsOfReferences()->first()),rhsTermPost}
						else Sequence{deletedEl,thisModule.SlotRefList(rl.SlotsOfReferences()),rhsTermPost}
						endif
					endif
			),
		deletedEl : Maude!RecTerm( --se crea el contenedor Set_ para el conjunto de elementos borrados
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			args <- if rl.deletedObjects() -> isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.deletedObjects()->size()=1 then thisModule.PatternElDeleted(rl.deletedObjects()->first())
						else thisModule.PatternElDeletedMany(rl.deletedObjects())							
						endif
					endif
			),
--		itemsDeleted : Maude!RecTerm(
--			op <- thisModule.bracketsOp, --{_}
--			type <- thisModule.itemListSort,
--			args <- if rl.deletedObjects() -> isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if rl.deletedObjects()->size()=1 then thisModule.PatternElDeleted(rl.deletedObjects()->first())
--						else thisModule.PatternElDeletedMany(rl.deletedObjects())							
--						endif
--					endif
--			),					
			
		rhsTermPost : Maude!RecTerm(
			op <- thisModule.modelOperator,
			type <- thisModule.sortModel, 
			args <- Sequence{mmrhsPost,rhsTermArgsPost}
			),
		mmrhsPost : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		rhsTermArgsPost : Maude!RecTerm(   --Cuidado: Aqu� estamos haciendo rhs de Maude, PERO RHS de Behavior
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 		
					Sequence{
					rl.objActExecRHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then rl.ObjectRHS2RecTermApplyOngoing(i)		
													else thisModule.ActEx2RecTerm(i,true)
													endif),
					--thisModule.CreateTimerRealization(rl,true),
					thisModule.CreateClock(rl.rhs),
					--thisModule.CreateCounter(rl.numObjCreatedInstantaneous()+1),
					--thisModule.CreateCounter(rl.numObjCreatedInstantaneousAux()+1),
					thisModule.CreateRandomCounter(true),thisModule.CreateOBJSET('')
					}
					->union(if rl.periodicity > 0.0 then Sequence{thisModule.CreateTimerRealization(rl,true),thisModule.CreateCounter(rl.numObjCreatedInstantaneous()+rl.vbles->size()+1)}
							else Sequence{thisModule.CreateCounter(rl.numObjCreatedInstantaneousAux()+rl.vbles->size()+1)}
							endif)
					--se a�aden tambi�n los elementos borrados (elementos de lhs que no aparecen en RHS) que ser�n manejados de una forma especial
					->union(rl.deletedElements()->collect(i|if i.oclIsTypeOf(Behavior!Object) then
																thisModule.Object2RecTerm(i,rl.lhs)
															else
																--thisModule.ActEx2RecTerm(i)
																thisModule.ActExInterrupted2RecTerm(i)
															endif)
															)
					
				)

		-------------------------FIN rhs(Maude) de la INSTANTANEOUS RULE------------------------------
		
	do{					
		for (p in rl.objActExecLHSRule()){
			thisModule.counter <- thisModule.counter +1;
			if (rl.periodicity > 0.0){
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			}
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondOR(thisModule.counter,thisModule.counter));
		}
		if (rl.periodicity > 0.0){
			for (p in rl.NewObjActExecRHS()){
				thisModule.counter <- thisModule.counter +1;
				crlpre.conds <- crlpre.conds -> prepend(thisModule.CondOR(thisModule.counter,thisModule.counter));
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});
			}		
		}
		thisModule.counter <- thisModule.counter +1;
		for (p in rl.vbles){
			thisModule.counterV <- thisModule.counterV +1;
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}
		thisModule.counterV <- 0;
		--Para los ORi de la parte derecha
		--for (p in rl.NewObjectsRHS()){
		for (p in rl.NewObjActExecRHS()){
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar(p.id,thisModule.counter));
			thisModule.counter <- thisModule.counter + 1;
		}
		thisModule.counter <- 0;
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;		
		
	
		thisModule.counterRhs <- 0;
		--Para crear las VARi@
		if (rl.periodicity > 0.0){
			for (p in rl.vbles){
				thisModule.counterVar <- thisModule.counterVar +1;
				--rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
			}
		}
		thisModule.counterVar <- 0;
		
		
		for (p in rl.rhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.newCounter));
			}
			thisModule.countORAE <- 0;
		}
		
		for(r in rl.deletedElements()->select(i|i.oclIsTypeOf(Behavior!ActionExec))){
			for (q in r.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				rhsTermArgsPost.args <- rhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
			}
			thisModule.countORAE <- 0;
		}			
		
		
		
		
-----------CONDICIONES QUE ESTARAN PRESENTES SEGUN LAS CARACTERISTICAS CONCRETAS DE LA REGLA---------------------------------

--Problema: las condiciones lowerbound y upperbound funcionan pero si al editar el modelo se seleccionan las propiedades
--ya no se detectan vac�as aunque las dejemos en blanco
--Soluci�n: En una versi�n posterior las propiedades upperBound y lowerBound pasaron a ser de tipo EFloat con valores por defecto
--de -1.0 y 0.0 respectivamente. 
		
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.LowerBoundCondition(rl));
		}
		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			crlpre.conds <- crlpre.conds -> append(thisModule.UpperBoundCondition(rl));
		}		

		---PARA PERIODIC RULES: se introduce la condici�n 'inPeriod'
		
--		if ((rl.oclIsTypeOf(Behavior!AtomicRule)) and (rl.periodicity > 0.0)){
--			crlpre.conds <- crlpre.conds -> append(thisModule.inPeriodCondition(rl));
--		}
		
		--Para reglas que NO sean "SOFT PERIODIC" se incluye la operaci�n 'multiple'
		--Si la regla fuera SOFT PERIODIC s incluir�a (en lugar de la operaci�n 'multiple') la condici�n alreadyExecInPeriod
--		if (rl.periodicity > 0.0){
--			if (rl.soft){
--				crlpre.conds <- crlpre.conds -> append(thisModule.AlreadyCondition(rl));
--				thisModule.AlreadyOpEq(rl);
--			}
--			else{
--				crlpre.conds <- crlpre.conds -> append(thisModule.multipleCondition(rl));
--			}
--		}
		
		if (rl.periodicity > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.AlreadyCondition(rl));
			thisModule.AlreadyOpEq(rl);					
			if (not rl.soft){
				crlpre.conds <- crlpre.conds -> append(thisModule.multipleCondition(rl));
			}
		}
		
		
--		if ((not rl.maxDuration.oclIsUndefined()) and rl.maxDuration<>''){
--			crlpre.conds <- crlpre.conds -> append(thisModule.MaxDurationComputation(rl));
--		}
		
----------------------------------------------------------------------------------------------------------------------------		
		
		--La operaci�n CURRENT EXEC sirve para evitar un numero indefinido de ejecuciones de la regla
		--thisModule.CurrentExecOp(rl);
		

		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			crlpre.conds <- crlpre.conds -> append(thisModule.DpoCondition(rl));
			}
		}


		--Si la regla tiene asociados patrones NAC se llama a una regla espec�fica para crear la operaci�n de dicho NAC
		for (p in rl.nacs){
			thisModule.OperationNac(p);
		}

		----La ecuaci�n mte se define para EAGER RULES. Dichas reglas se ejecutan tan pronto como es posible.
		if (not((rl.soft) and not(rl.periodicity > 0.0 ))){			
			thisModule.mteInmediate(rl);
		}
		
		crlpre.conds <- crlpre.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));
	}
}


		
		
rule AtomicRuleWithoutDuration2Rule{  
	from
		rl : Behavior!AtomicRule (rl.minDuration.oclIsUndefined() or rl.minDuration='')
	to		
		crlpre : Maude!Rule( 		
			"module" <- thisModule.mainModule,
			label <- rl.name.processSpecOpChars() + '@Triggering',
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			conds <- Sequence{thisModule.TimerCond(''),thisModule.lhsCond(rl)}-> --,thisModule.CurrentExecCondition(rl)} ->
						union(rl.vbles -> collect(s|thisModule.VarComputation(s))) ->
						union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t))) ->
						union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->
						--append(thisModule.MinDurationComputation(rl)) ->
						--append(thisModule.MaxDurationComputation(rl)) ->
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))	
			),
			
		--------------- lhs(Maude) de la TRIGGERING RULE (representa el modelo) -----------------------	
		lhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),					
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}	
			),
			
		-----------------------------------FIN  lhs(Maude) de la Triggering rule------------------------------------------
		
		----------------------------------- rhs(Maude) de la Triggering rule ---------------------------------------------
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mmrhs,rhsTermArgs}
			),
		mmrhs : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),				
		rhsTermArgs : Maude!RecTerm( --Cuidado: Aqu� estamos haciendo rhs de Maude, PERO LHS de Behavior
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimer(rl),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(rl.objActExecLHSRule()->size()+rl.vbles->size()+1),
					thisModule.CreateRandomCounter(true),thisModule.CreateOBJSET('')
					}	
			)		
		
		--------------------FIN rhs(Maude) de la TRIGGERING rule-------------
		
		--------------------------------------------------------------------- 
		-------------------------- FIN TRIGGERING RULE ----------------------
		---------------------------------------------------------------------	
	do{		
		for (p in rl.objActExecLHSRule()){			
			thisModule.counter <- thisModule.counter +1;
			rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});		
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondOR(thisModule.counter,thisModule.counter));
		}
		thisModule.counterRhs <- thisModule.counter;		
		thisModule.counter <- thisModule.counter +1;
		for (p in rl.vbles){
			thisModule.counterV <- thisModule.counterV +1;
			crlpre.conds <- crlpre.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}		
		thisModule.counterV <- 0;
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;
		thisModule.counter <- 0;
		thisModule.counterRhs <- 0;
		thisModule.newCounter <- 0;
		
		
		--Para crear las VARi@
		for (p in rl.vbles){
			thisModule.counterVar <- thisModule.counterVar +1;
			rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});			
		}
		thisModule.counterVar <- 0;
		
-----------CONDICIONES QUE ESTARAN PRESENTES SEGUN LAS CARACTERISTICAS CONCRETAS DE LA REGLA---------------------------------

--Problema: las condiciones lowerbound y upperbound funcionan pero si al editar el modelo se seleccionan las propiedades
--ya no se detectan vac�as aunque las dejemos en blanco
--Soluci�n: En una versi�n posterior las propiedades upperBound y lowerBound pasaron a ser de tipo EFloat con valores por defecto
--de -1.0 y 0.0 respectivamente. Al tener un valor pr defecto ya no se detecta el problema anterior.
		
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.LowerBoundCondition(rl));
		}

		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			crlpre.conds <- crlpre.conds -> append(thisModule.UpperBoundCondition(rl));
		}
		
		---PARA PERIODIC RULES: se introduce la condici�n 'inPeriod'
		
--		if ((rl.oclIsTypeOf(Behavior!AtomicRule)) and (rl.periodicity > 0.0)){
--			crlpre.conds <- crlpre.conds -> append(thisModule.inPeriodCondition(rl));
--		}
		
		--Para reglas que NO sean "SOFT PERIODIC" se incluye la operaci�n 'multiple'
		--Si la regla fuera SOFT PERIODIC s incluir�a (en lugar de la operaci�n 'multiple') la condici�n alreadyExecInPeriod
--		if (rl.periodicity > 0.0){
--			if (rl.soft){   --and rl.periodicity <> -1.0 ){
--				crlpre.conds <- crlpre.conds -> append(thisModule.AlreadyCondition(rl));
--				thisModule.AlreadyOpEq(rl);
--			}
--			else{
--				crlpre.conds <- crlpre.conds -> append(thisModule.multipleCondition(rl));
--			}
--		}
			
		if (rl.periodicity > 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.AlreadyCondition(rl));
			thisModule.AlreadyOpEq(rl);					
			if (not rl.soft){
				crlpre.conds <- crlpre.conds -> append(thisModule.multipleCondition(rl));
			}
		}
			
		if ((not rl.maxDuration.oclIsUndefined()) and rl.maxDuration<>''){
			crlpre.conds <- crlpre.conds -> append(thisModule.MaxDurationComputation(rl));
		}
        
-----------------------------------------------------------------------------------------------------------------------		
		
		--Si la regla tiene asociados patrones NAC se llama a una regla espec�fica para crear la operaci�n y las ecuaciones 
		--de dicho NAC
		for (p in rl.nacs){
			thisModule.OperationNac(p);
		}


		
		--La operaci�n CURRENT EXEC sirve para evitar un numero indefinido de ejecuciones de la regla. Esta llamada a una lazy rule
		--crear� dicha operaci�n y sus ecuaciones
		--thisModule.CurrentExecOp(rl);
		if (rl.periodicity = 0.0){
			crlpre.conds <- crlpre.conds -> append(thisModule.CurrentExecCondition(rl));
			thisModule.CurrentExecOp(rl);
		}		
		
		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			crlpre.conds <- crlpre.conds -> append(thisModule.DpoCondition(rl));
			}
		}
		
		----La ecuaci�n mte se define para EAGER RULES. Dichas reglas se ejecutan tan pronto como es posible.
		if (not((rl.soft) and not(rl.periodicity > 0.0 ))){			
			thisModule.mte(rl);
		}
		
--�������ESTO ESTA AQUI PARA HACER LAS PRUEBAS CON EL EJEMPLO DEL MOVIL PARA HACER QUE EL MOVIL!!!!!! 
--�������SE ENCIENDA OBLIGATORIAMENTE EN CUANTO PUEDA!!!!!!!!
--������HAY QUE ELIMINARLA!!!!!!!
--		if (rl.name='SwitchOn'){
--			thisModule.mte(rl);
--		}
		
		-- Esta condici�n puede crearse dentro de la parte declarativa de la regla. Se va a crear aqu� porque en el caso de que haya variables
		-- vamos a necesitar que esta condici�n aparezca despues de la inicializaci�n de variables por ello la generamos despu�s.
		-- Se intent� insertar la condici�n de inicializaci�n antes en la secuencia mediante los comandos "prepend" y "insertAt"
		-- pero no funcionan correctamente
		crlpre.conds <- crlpre.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));
	}
}
		
		
		
		
		
		
		







-- Reglas Eager necesitan esta ecuacion adicional. Las reglas periodicas tambien
-- No la necesitan las Soft Rules q no son Periodicas

lazy rule mte{
	from
		rl :Behavior!Rule
	to
		eq : Maude!Equation(
			"module" <- thisModule.mainModule,
			label <- rl.name,
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			conds <-
					Sequence{thisModule.lhsCond(rl)} -> --,
						--thisModule.CurrentExecCondition(rl)} ->
						--union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t))) ->
						--union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->						
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))	
			),
		lhsTerm : Maude!RecTerm(
			op <- 'mte',
			type <- thisModule.oclExpSort,
			args <- lhsT
			),
		lhsT : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.intSort,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
			
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}						
				),			
		rhsTerm : Maude!Constant(
			op <- '0',
			type <- thisModule.intSort
			)
	do{
		--thisModule.counter <- rl.objectsLHSRule()->size()+1;
		thisModule.counter <- rl.objActExecLHSRule()->size()+1;
		for (p in rl.vbles){
			thisModule.counterV <- thisModule.counterV +1;
			--eq.conds <- eq.conds -> union(Sequence{thisModule.CondVAR(thisModule.counterV,thisModule.counter)});
			eq.conds <- eq.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}

		thisModule.counter <- 0;
		thisModule.counterV <- 0;
		
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;		
		
		
		if (rl.oclIsTypeOf(Behavior!AtomicRule)){			
			eq.conds <- eq.conds -> union(rl.vbles -> collect(s|thisModule.VarComputation(s)));

		}
		
		--if (not rl.lowerBound.oclIsUndefined() and ( rl.lowerBound.toString() <> '')){
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			eq.conds <- eq.conds -> append(thisModule.LowerBoundCondition(rl));
		}
		
		--if (not rl.upperBound.oclIsUndefined() and ( rl.upperBound.toString() <> '')) {
		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			eq.conds <- eq.conds -> append(thisModule.UpperBoundCondition(rl));
		}
		

		if (rl.oclIsTypeOf(Behavior!AtomicRule)){
			if (rl.periodicity > 0.0){
				eq.conds <- eq.conds -> append(thisModule.AlreadyCondition(rl));
				---thisModule.AlreadyOpEq(rl);				
				if (not rl.soft){
					eq.conds <- eq.conds -> append(thisModule.multipleCondition(rl));
				}
			}
		}


		
		eq.conds <- eq.conds -> union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t)));
		eq.conds <- eq.conds -> union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r)));		
		eq.conds <- eq.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));
		
		if (rl.oclIsTypeOf(Behavior!AtomicRule)){
			if (rl.periodicity = 0.0){
				eq.conds <- eq.conds -> append(thisModule.CurrentExecCondition(rl));
			}
		}
		
		if (rl.oclIsTypeOf(Behavior!OngoingRule)){
			eq.conds <- eq.conds -> append(thisModule.CurrentExecCondition(rl));
			if (not(rl.maxDuration.oclIsUndefined() or rl.maxDuration='')){
				eq.conds <- eq.conds -> append(thisModule.MaxDurationOngoingComputation(rl,false));
			}
		}	
		
		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			eq.conds <- eq.conds -> append(thisModule.DpoCondition(rl));
			}
		}
		
	}
}



lazy rule mteInmediate{
	from
		rl :Behavior!Rule
	to
		eq : Maude!Equation(
			"module" <- thisModule.mainModule,
			label <- rl.name,
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			conds <- 
					Sequence{thisModule.LhsCondInstantaneous(rl)}->
						union(rl.lhs.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))	
			),
		lhsTerm : Maude!RecTerm(
			op <- 'mte',
			type <- thisModule.oclExpSort,
			args <- lhsT
			),
		lhsT : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.intSort,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
			
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, -- '__'
			type <- thisModule.sortSetObject,
			args <- 				
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermApplyOngoingLHS(i,rl.lhs)		
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}					
			),			
		rhsTerm : Maude!Constant(
			op <- '0',
			type <- thisModule.intSort
			)
	do{
		thisModule.counter <- rl.objActExecLHSRule()->size()+1;
		for (p in rl.vbles){
			thisModule.counterV <- thisModule.counterV +1;
			eq.conds <- eq.conds -> prepend(thisModule.CondVAR(thisModule.counterV,thisModule.counter));
			thisModule.counter <- thisModule.counter +1;
		}

		thisModule.counter <- 0;
		thisModule.counterV <- 0;
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});			
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;			
		
		
		if (rl.oclIsTypeOf(Behavior!AtomicRule)){
			eq.conds <- eq.conds -> union(rl.vbles -> collect(s|thisModule.VarComputation(s)));
--			eq.conds <- eq.conds -> append(thisModule.MinDurationComputation(rl));
--			if ((not rl.maxDuration.oclIsUndefined()) and rl.maxDuration<>''){
--				eq.conds <- eq.conds -> append(thisModule.MaxDurationComputation(rl));
--			}
		}
		
		--if (not rl.lowerBound.oclIsUndefined() and ( rl.lowerBound.toString() <> '')){
		if (rl.lowerBound < 0.0 or rl.lowerBound > 0.0){
			eq.conds <- eq.conds -> append(thisModule.LowerBoundCondition(rl));
		}
		
		--if (not rl.upperBound.oclIsUndefined() and ( rl.upperBound.toString() <> '')) {
		if (rl.upperBound < -1.0 or rl.upperBound > -1.0) {
			eq.conds <- eq.conds -> append(thisModule.UpperBoundCondition(rl));
		}
		


		if (rl.oclIsTypeOf(Behavior!AtomicRule)){
			if (rl.periodicity > 0.0){
				--eq.conds <- eq.conds -> append(thisModule.inPeriodCondition(rl));			
				eq.conds <- eq.conds -> append(thisModule.AlreadyCondition(rl));
				---thisModule.AlreadyOpEq(rl);				
				if (not rl.soft){
					eq.conds <- eq.conds -> append(thisModule.multipleCondition(rl));
				}
			}
		}			
		
		eq.conds <- eq.conds ->union(rl.objectsLHSRule() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t)));
		eq.conds <- eq.conds ->union(rl.lhs.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r)));
		
		eq.conds <- eq.conds -> union(rl.nacs -> collect(o|thisModule.NacsCond(o)));
		
		if ( not rl.behavior.oclIsUndefined() ){
			if ( rl.behavior.formalization = #dpo ){
			eq.conds <- eq.conds -> append(thisModule.DpoCondition(rl));
			}
		}
	}
}









		
		
		

		
------------------------------------------------------------------------------------------------------------
-------------------------- REGLAS PARA LOS ACTION EXECUTIONS------------------------------------------------

--------------------- Crea un contenedor si hay un conjunto de elementos ACTIONEXEC ------------------------
--lazy rule ManyActEx2RecTerm{
--	from
--		p : Behavior!Pattern
--	to
--		l : Maude!RecTerm(
--			op <- thisModule.objSetOperator,--'__', 
--			type <- thisModule.sortSetObject,
--			args <- --Sequence{(p.ActionExecEls()->select(e|e.oclIsTypeOf(Behavior!ActionExec))) -> collect(a|thisModule.ActEx2RecTerm(a))}
--					Sequence{(p.ActionExecEls()->collect(a|thisModule.ActEx2RecTerm(a)))}
--			)
--}
-------------------------------------------------------------------------------------------------------------

------------------------ Crea el objeto correspondiente a un elemento ACTIONEXEC-----------------------------
lazy rule ActEx2RecTerm{
	from
		ae : Behavior!ActionExec,
		aeExistsInRHS : Boolean
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <- Sequence{oid,cte,argms}
			),
		oid : Maude!Variable(
			name <- ae.id,
			type <- thisModule.oclTypeSort
			),
		cte : Maude!Constant(
			op <- 'AtomicActionExec@MGBehavior',
			type <- thisModule.sortAtActExec
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- --Sequence{action,ending,timer,partic,sfs}
--					if ae.startingTime.oclIsUndefined() or ae.startingTime = '' then
--						if ae.executionTime.oclIsUndefined() or ae.executionTime='' then
--							Sequence{action,ending,status,partic,sfs}
--						else
--							Sequence{action,ending,status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
--						endif
--					else						
--						if ae.executionTime.oclIsUndefined() or ae.executionTime='' then							
--							Sequence{thisModule.CreateStartingTimeFeature(ae),action,ending,status,partic,sfs}
--						else
--							Sequence{thisModule.CreateStartingTimeFeature(ae),action,ending,status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
--						endif
--					endif
					if ae.startingTime.oclIsUndefined() or ae.startingTime = '' then
						if ae.endingTime.oclIsUndefined() or ae.endingTime='' then
							if not aeExistsInRHS then
								if ae.executionTime.oclIsUndefined() or ae.executionTime='' then
									Sequence{action,thisModule.CreateEndingTimeFeatureVAR(''),status,partic,sfs}
								else
									Sequence{action,thisModule.CreateEndingTimeFeatureVAR(''),status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
								endif
							else
								if ae.executionTime.oclIsUndefined() or ae.executionTime='' then
									Sequence{action,status,partic,sfs}
								else
									Sequence{action,status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
								endif
							endif
						else
							if ae.executionTime.oclIsUndefined() or ae.executionTime='' then
								Sequence{action,thisModule.CreateEndingTimeFeature(ae),status,partic,sfs}
							else
								Sequence{action,thisModule.CreateEndingTimeFeature(ae),status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
							endif
						endif
					else
						if ae.endingTime.oclIsUndefined() or ae.endingTime='' then
							if not aeExistsInRHS then
								if ae.executionTime.oclIsUndefined() or ae.executionTime='' then							
									Sequence{thisModule.CreateStartingTimeFeature(ae),action,thisModule.CreateEndingTimeFeatureVAR(''),status,partic,sfs}
								else
									Sequence{thisModule.CreateStartingTimeFeature(ae),action,thisModule.CreateEndingTimeFeatureVAR(''),status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
								endif
							else
								if ae.executionTime.oclIsUndefined() or ae.executionTime='' then							
									Sequence{thisModule.CreateStartingTimeFeature(ae),action,status,partic,sfs}
								else
									Sequence{thisModule.CreateStartingTimeFeature(ae),action,status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
								endif
							endif
						else
							if ae.executionTime.oclIsUndefined() or ae.executionTime='' then							
								Sequence{thisModule.CreateStartingTimeFeature(ae),action,thisModule.CreateEndingTimeFeature(ae),status,partic,sfs}
							else
								Sequence{thisModule.CreateStartingTimeFeature(ae),action,thisModule.CreateEndingTimeFeature(ae),status,partic,thisModule.CreateExecutionTimeFeature(ae),sfs}
							endif
						endif
					endif
			),
			
		-----action@ActionExec@MGBehavior------ (nombre de la acci�n)
		action : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- --Sequence{actionConst,actionVar}
					if ae.action.oclIsUndefined() then Sequence{actionConst,thisModule.CreateVariable('ACTION@'+ae.id+'@ATT',thisModule.stringSort)}
					else Sequence{actionConst,thisModule.CreateConstant('"'+ ae.action.name +'"',thisModule.stringSort)}
					endif
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		----------------------------------------
			
		-----ending@ActionExec@MGBehavior-------
--		ending : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{endingConst,
--				--if ae.past then
--				if ae.status <> #unfinished then
--					if (ae.endingTime.oclIsUndefined() or ae.endingTime = '') then thisModule.CreateVariable('ENDINGTIME@'+ae.id+'@ATT',thisModule.timeSort) --thisModule.EndingVar(ae)
--					else thisModule.allOclExpressions->any(i|ae.endingTime=i.name).initExpression.oclExpConverter()							
--					endif
--				else thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort) --thisModule.EndingConstant(ae)
--				endif
--			}
--			),
--		endingConst : Maude!Constant(
--			op <- 'endingTime@ActionExec@MGBehavior',
--			type <- thisModule.sortAttribute
--			),
		----------------------------------------


		-------status@AtomicActionExec@MGBehavior---------------
		
		status : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{statusLeft,statusRight}
			),
		statusLeft : Maude!Constant(
			op <- 'status@AtomicActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		statusRight : Maude!Constant(
			op <-  ae.status.toString()+'@ActionStatus@MGBehavior', 
			type <- thisModule.actionStatusSort
			),
		
	    ----participants@ActionExec@MGBehavior------------------		
		partic : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,setParticipants}					
			),
		setParticipants : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,			
			args <- if ae.participants->isEmpty() then participantsVar
					else thisModule.ObjRoleMany(ae,participantsVar)
					endif
			),
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet--rl.LHSRule().oidOfORType() --thisModule.sortRefSimple 
			),
		participantsVar : Maude!Variable(
			name <- 'L@'+ae.id,
			type <- thisModule.mSetSort --thisModule.listSort
			),
		sfs : Maude!Variable(
			name <- ae.id + '@SFS',
			type <- thisModule.sortSetSfi
			)
}


------------------------ Crea el objeto correspondiente a un elemento ACTIONEXEC-----------------------------
lazy rule ActExInterrupted2RecTerm{
	from
		ae : Behavior!ActionExec
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <- Sequence{oid,cte,argms}
			),
		oid : Maude!Variable(
			name <- ae.id,
			type <- thisModule.oclTypeSort
			),
		cte : Maude!Constant(
			op <- 'AtomicActionExec@MGBehavior',
			type <- thisModule.sortAtActExec
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- --Sequence{action,ending,timer,partic,sfs}
					if ae.startingTime.oclIsUndefined() or ae.startingTime = '' then Sequence{action,ending,status,partic,sfs}
					else Sequence{thisModule.CreateStartingTimeFeature(ae),action,ending,status,partic,sfs}
					endif
			),
			
		-----action@ActionExec@MGBehavior------ (nombre de la acci�n)
		action : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- --Sequence{actionConst,actionVar}
					if ae.action.oclIsUndefined() then Sequence{actionConst,thisModule.CreateVariable('ACTION@'+ae.id+'@ATT',thisModule.stringSort)}
					else Sequence{actionConst,thisModule.CreateConstant('"'+ ae.action.name +'"',thisModule.stringSort)}
					endif
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		----------------------------------------
			
		-----ending@ActionExec@MGBehavior-------(su valor depende del atributo past)
		ending : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{endingConst,thisModule.CreateVariable('TIME@CLK@',thisModule.timeSort) --thisModule.timeInfSort)
--					if (ae.endingTime.oclIsUndefined() or ae.endingTime = '') then thisModule.CreateVariable('ENDINGTIME@'+ae.id+'@ATT',thisModule.timeSort) --thisModule.EndingVar(ae)
--					else --thisModule.EndingConstant(ae)
--						thisModule.allOclExpressions->any(i|ae.endingTime=i.name).initExpression.oclExpConverter()							
--					endif
			}
			),
		endingConst : Maude!Constant(
			op <- 'endingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),


		-------status@AtomicActionExec@MGBehavior---------------
		
		status : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{statusLeft,statusRight}
			),
		statusLeft : Maude!Constant(
			op <- 'status@AtomicActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		statusRight : Maude!Constant(
			op <- 'interrupted@ActionStatus@MGBehavior',--ae.status.toString(),
			type <- thisModule.actionStatusSort
			),
		
	    ----participants@ActionExec@MGBehavior------------------		
		partic : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,setParticipants}					
			),
		setParticipants : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			args <- if ae.participants->isEmpty() then participantsVar
					else thisModule.ObjRoleMany(ae,participantsVar)
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- if ae.participants->isEmpty() then participantsVar
--					else thisModule.ObjRoleMany(ae,participantsVar)
--					endif
--			),		
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet
			),
		participantsVar : Maude!Variable(
			name <- 'L@'+ae.id,
			type <- thisModule.mSetSort 
			),
		sfs : Maude!Variable(
			name <- ae.id + '@SFS',
			type <- thisModule.sortSetSfi
			)
}





		-- Reglas auxiliares para ActEx2RecTerm
		lazy rule CreateVariable{
			from
				nameVar : String,
				typeVar : Maude!Sort
			to
				var : Maude!Variable(
					name <- nameVar,
					type <- typeVar
					)
		}
		lazy rule CreateConstant{
			from
				nameConst : String,
				typeConst : Maude!Sort
			to
				const : Maude!Constant(
					op <- nameConst,
					type <- typeConst
					)
		}
		
		lazy rule ObjRoleMany{
			from
				ae : Behavior!ActionExec,
				pVar : Maude!Variable
			to
				rt : Maude!RecTerm(
					op <- thisModule.mSetOperator, --'_;_'
					type <- thisModule.mSetSort, 
					args <- Sequence{pVar}
					)
			do{
				for (p in ae.participants){
						thisModule.counterObjR <- thisModule.counterObjR +1;
						rt.args <- rt.args -> append(thisModule.OidOR('OR'+ thisModule.counterObjR.toString()+'@'+ae.id));
					}
				thisModule.counterObjR <- 0;
			}
		}
		
		lazy rule CreateStartingTimeFeature{
			from
				ae : Behavior!ActionExec
			to
				starting : Maude!RecTerm(
					op <- thisModule.sfsOperator, -- '_:_'
					type <- thisModule.sortRefInst,
					args <- Sequence{startingConst,thisModule.allOclExpressions->any(i|ae.startingTime=i.name).initExpression.oclExpConverter()}						
					),
				startingConst : Maude!Constant(
					op <- 'startingTime@ActionExec@MGBehavior',
					type <- thisModule.sortAttribute
					)
		}
		
		lazy rule CreateEndingTimeFeature{
			from
				ae : Behavior!ActionExec
			to
				ending : Maude!RecTerm(
					op <- thisModule.sfsOperator, -- '_:_'
					type <- thisModule.sortRefInst,
					args <- Sequence{endingConst,thisModule.allOclExpressions->any(i|ae.endingTime=i.name).initExpression.oclExpConverter()}						
						--if ae.status <> #unfinished then
							--if (ae.endingTime.oclIsUndefined() or ae.endingTime = '') then thisModule.CreateVariable('ENDINGTIME@'+ae.id+'@ATT',thisModule.timeSort) --thisModule.EndingVar(ae)
							--else 
								--thisModule.allOclExpressions->any(i|ae.endingTime=i.name).initExpression.oclExpConverter()							
							--endif
						--else thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort) --thisModule.EndingConstant(ae)
						--endif
						--}
					),
				endingConst : Maude!Constant(
					op <- 'endingTime@ActionExec@MGBehavior',
					type <- thisModule.sortAttribute
					)
		}
		
	
		lazy rule CreateEndingTimeFeatureVAR{
			from
				blank : String
			to
				ending : Maude!RecTerm(
					op <- thisModule.sfsOperator, -- '_:_'
					type <- thisModule.sortRefInst,
					args <- Sequence{endingConst,endingVar}												
					),
				endingConst : Maude!Constant(
					op <- 'endingTime@ActionExec@MGBehavior',
					type <- thisModule.sortAttribute
					),
				endingVar : Maude!Variable(
					name <- 'ENDINGTIME@',
					type <- thisModule.oclTypeSort
					)
		}
		
		
		
		lazy rule CreateExecutionTimeFeature{
			from
				ae : Behavior!ActionExec
			to
				execution : Maude!RecTerm(
					op <- thisModule.sfsOperator, -- '_:_'
					type <- thisModule.sortRefInst,
					args <- Sequence{executionConst,toRat}
						--Sequence{executionConst,thisModule.allOclExpressions->any(i|ae.executionTime=i.name).initExpression.oclExpConverter()}						
					),
				executionConst : Maude!Constant(
					op <- 'executionTime@ActionExec@MGBehavior',
					type <- thisModule.sortAttribute
					),
				toRat : Maude!RecTerm(
					op <- thisModule.toRatOperator,
					type <- thisModule.ratSort,
					args <- thisModule.allOclExpressions->any(i|ae.executionTime=i.name).initExpression.oclExpConverter()
					)
		}
		---Regla para crear los objetos 'ORi' que representan los objetos que participan en la regla----

		lazy rule CreateObjRoleActionExec{
			from
				obR : Behavior!ObjectRole,
				cont : Integer		
			to
				obRole : Maude!RecTerm(
					op <- thisModule.objectOperator, -- '<_:_|_>'
					type <- thisModule.sortObject,
					args <-	Sequence{id,objClass,argms}
					),
				id : Maude!Variable(
					name <- 'OR'+cont.toString()+'@'+obR.actionExec.id,
					type <- thisModule.sortOid
					),
				objClass : Maude!Constant(
					op <- 'ObjectRole@MGBehavior',
					type <- thisModule.sortObjRole
					),
				argms : Maude!RecTerm(
					op <- thisModule.featOperator, -- '_`,_'
					type <- thisModule.sortSetSfi,
					args <- if obR.role.oclIsUndefined() then 
								Sequence{objActual,thisModule.CreateVariable('OR'+cont.toString()+'@'+obR.actionExec.id+'@SFS',thisModule.sortSetSfi)}--objSFS}
							else 
								Sequence{objActual,thisModule.CreateRole(obR)}
							endif
					),
				objActual : Maude!RecTerm(
					op <- thisModule.sfsOperator, -- '_:_'
					type <- thisModule.sortRefInst,
					args <- Sequence{constObj,varObj}
					),
				constObj : Maude!Constant(
					op <-  'actualObject@ObjectRole@MGBehavior',
					type <- thisModule.sortRefSimple		
					),
				varObj : Maude!Variable(
					name <- obR.actualObject.id,
					type <- thisModule.oclTypeSort
					) 
		}

		lazy rule CreateRole{
			from
				obR : Behavior!ObjectRole
			to
				objRole : Maude!RecTerm(
					op <- thisModule.sfsOperator, -- '_:_'
					type <- thisModule.sortRefInst,
					args <- --Sequence{constObj,varObj}
							Sequence{constObj,cteObj}
					),
				constObj : Maude!Constant(
					op <-  'role@ObjectRole@MGBehavior',
					type <- thisModule.sortRefSimple		
					),
--				varObj : Maude!Variable(
--					name <- '"'+obR.role.id+'"',
--					type <- thisModule.oclTypeSort
--					),
				cteObj : Maude!Constant(
					op <- '"'+obR.role.id+'"',
					type <- thisModule.oclTypeSort
					)
		}

----------FIN REGLAS PARA LOS ACTION EXECUTIONS------------------
-----------------------------------------------------------------		
		
		
		
		
		
----------------------------------------------------------------------------		
---------------------ARGUMENTOS DE READJUST---------------------------------		
----------------------------------------------------------------------------		

lazy rule SlotRefSimple{
	from
		slot : Behavior!Slot
	to
		oper : Maude!RecTerm(
			op <- thisModule.linkOperator, -- link
			type <- thisModule.linkSort,
			args <- Sequence{source,reference,evalVar,evalExp}
--					if slot.object.existObjInLHS(slot.object.pattern) then Sequence{source,reference,thisModule.SlotRefSimpleAux(slot),evalExp}
--					else Sequence{source,reference,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort),evalExp} 
--					endif
			),
		source : Maude!Variable(
			name <- slot.object.id, -- lnk.src.id,
			type <- thisModule.oclTypeSort
			),
		reference : Maude!Constant(
			op <- slot.sf.maudeName().processSpecOpChars(),
			type <- thisModule.sortRefSimple
			),	
			
		evalVar : Maude!RecTerm(
			op <- thisModule.evalOperator, --'eval'
			type <- thisModule.oclExpSort,
			args <- Sequence{asSeqEvalVar,envEvalVar,modelEvalVar}
			),
		asSeqEvalVar : Maude!RecTerm(
			op <- '_->`asSequence`(`)',
			type <- thisModule.oclExpSort,
			args <- --refVarEvalVar
					if slot.object.existObjInLHS(slot.object.pattern) then thisModule.CreateVariable(slot.sf.name.toUpper().processSpecOpChars()+'@'+slot.object.id+'@ATT',thisModule.oclTypeSort)
					else thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)
					endif
			),	
--		refVarEvalVar : Maude!Variable(
--			name <- slot.sf.name.toUpper().processSpecOpChars()+'@'+slot.object.id+'@ATT',
--			type <- thisModule.oclTypeSort  
--			),
		envEvalVar : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyEvalVar
			),
		emptyEvalVar : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		modelEvalVar : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			),
			
			
		evalExp : Maude!RecTerm(
			op <- thisModule.evalOperator, --'eval'
			type <- thisModule.oclExpSort,
			args <- Sequence{asSeqEvalExp,envEvalExp,modelEvalExp}
			),
		asSeqEvalExp : Maude!RecTerm(
			op <- '_->`asSequence`(`)',
			type <- thisModule.oclExpSort,
			args <- thisModule.allOclExpressions->any(i|slot.oclValue=i.name).initExpression.oclExpConverter()
			),	
		envEvalExp : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyEvalExp
			),
		emptyEvalExp : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		modelEvalExp : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)	
			
}


--lazy rule SlotRefSimpleAux{
--	from
--		slot : Behavior!Slot
--	to
--		evalVar : Maude!RecTerm(
--			op <- thisModule.evalOperator, --'eval'
--			type <- thisModule.oclExpSort,
--			args <- Sequence{asSeqEvalVar,envEvalVar,modelEvalVar}
--			),
--		asSeqEvalVar : Maude!RecTerm(
--			op <- '_->`asSequence`(`)',
--			type <- thisModule.oclExpSort,
--			args <- refVarEvalVar					
--			),	
--		refVarEvalVar : Maude!Variable(
--			name <- slot.sf.name.toUpper().processSpecOpChars()+'@'+slot.object.id+'@ATT',
--			type <- thisModule.oclTypeSort  
--			),
--		envEvalVar : Maude!RecTerm(
--			op <- thisModule.envOperator,
--			type <- thisModule.msgSort,
--			args <- emptyEvalVar
--			),
--		emptyEvalVar : Maude!Constant(
--			op <- thisModule.emptyOperator,
--			type <- thisModule.emptySetSort
--			),		
--		modelEvalVar : Maude!Variable(
--			name <- 'MODEL@',
--			type <- thisModule.sortModel
--			)
--}		




lazy rule SlotRefList{
	from
		slotList : Sequence(Behavior!Slot)
	to
		recT : Maude!RecTerm(
			op <- thisModule.myLinkListOperator, --'__'     --thisModule.listOrdOperator, -- '_;_'
			type <- thisModule.myLinkListSort, --thisModule.listOrdSort, -- thisModule.myLinkListSort,
			args <- Sequence{slotList->collect(i|thisModule.SlotRefSimple(i))}		
			)
}



---------------------------------------------------------------------------

----Crea una variable con el id de un elemento(Object o ActionExec)----- 
lazy rule PatternElDeleted{
	from
		pe : Behavior!PatternEl
	to
		oid : Maude!Variable(
			name <- pe.id,
			type <- thisModule.oclTypeSort
		)
}


----Crea un termino con el operador de multiples elementos de un conjunto---
lazy rule PatternElDeletedMany{
	from
		del : Sequence(Behavior!PatternEl)
	to
		recT : Maude!RecTerm(
			op <- thisModule.mSetOperator, --'_;_'  --thisModule.setOperator,
			type <- thisModule.mSetSort, --thisModule.listSort,
			args <- Sequence{del->collect(i|thisModule.PatternElDeleted(i))}
			)
}
-----------------------------------------------------------------------------










--------------------------------------------------COUNTER-----------------------------
--Esta regla permite crear el objeto counter presente en toda regla. Cuando se llama a esta regla se le pasa un valor entero.
--De inicio el valor 'value' del contador estar� determinado por la variable VALUE@CNT@.
--Cuando la regla es �disparada? (triggered) se va a programar la acci�n, en ese caso el contador adopta el valor VALUE@CNT@+numero de variables+1
lazy rule CreateCounter{
	from
		num : Integer
	to
		counter : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidCounter,cteCounter,argsCounter}
			),
--		oidCounter : Maude!Variable(
--			name <- 'CNT@',---'\'ids@',
--			type <- thisModule.sortOid
--			),
		oidCounter : Maude!Constant(
			op <- '\'ids@',
			type <- thisModule.sortOid
			),
		cteCounter : Maude!Constant(
			op <- 'Counter@MGBehavior',
			type <- thisModule.sortCounter
			),
		argsCounter : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- if num >0 then 	Sequence{valueConst,thisModule.VarConstSum(num.toString(),valueVar)}
					else Sequence{valueConst,valueVar}
					endif
			),
		valueConst : Maude!Constant(
			op <-  'value@Counter@MGBehavior',
			type <- thisModule.sortAttribute 
			),
		valueVar : Maude!Variable(
			name <- 'VALUE@ids@',--'VALUE@CNT@',
			type <- thisModule.intSort
		)
}

lazy rule VarConstSum{
	from
		num : String,
		var : Maude!Variable
	to
		oper : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{var,const}
			),
		const : Maude!Constant(
			op <- num,
			type <- thisModule.intSort
			)	
}
------------------------------------- FIN COUNTER---------------------------------------

lazy rule CreateRandomCounter{
	from
		isRHS : Boolean
	to
		counter : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidCounter,cteCounter,argsCounter}
			),
		oidCounter : Maude!Constant(
			op <- '\'rdm@',
			type <- thisModule.sortOid
			),
		cteCounter : Maude!Constant(
			op <- 'Counter@MGBehavior',
			type <- thisModule.sortCounter
			),
		argsCounter : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- --Sequence{valueConst,valueVar}
					if isRHS then 	Sequence{valueConst,thisModule.VarConstSum(thisModule.numberOfRandoms.toString(),valueVar)}
					else Sequence{valueConst,valueVar}
					endif
			),
		valueConst : Maude!Constant(
			op <-  'value@Counter@MGBehavior',
			type <- thisModule.sortAttribute 
			),
		valueVar : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
		)
}







-----------------------------------------CLOCK-------------------------------------------
--Regla para crear el objeto Clock
lazy rule CreateClock{
	from
		--blank : String
		p : Behavior!Pattern
	to
		clock : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidClock,cteClock,argsClock}
			),
		oidClock : Maude!Variable(
			name <- --'CLK@',  ---Supongo que s�lo puede haber un elemento de tipo CLOCK
					if p.els->notEmpty() then
						if p.els->exists(i|i.oclIsTypeOf(Behavior!Clock)) then p.els->select(i|i.oclIsTypeOf(Behavior!Clock))->first().id
						else 'CLK@'
						endif
					else 'CLK@'
					endif,
			type <- --thisModule.sortOid
					if p.els->notEmpty() then
						if p.els->exists(i|i.oclIsTypeOf(Behavior!Clock)) then thisModule.oclTypeSort
						else thisModule.sortOid
						endif
					else thisModule.sortOid
					endif
			),
		cteClock : Maude!Constant(
			op <- 'Clock@MGBehavior',
			type <- thisModule.sortClock
			),			
		argsClock : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{timeConst,timeVar}
			),
		timeConst : Maude!Constant(
			op <-  'time@Clock@MGBehavior',
			type <- thisModule.sortAttribute
			),
		timeVar : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
		)
}
---------------------- FIN CLOCK ------------------------------------



----------------------- OBJSET ------------------
--La variable OBJSET representa el resto de elementos de un modelo
lazy rule CreateOBJSET{
	from
		blank : String
	to
		objSet : Maude!Variable(
			name <- 'OBJSET@',
			type <- thisModule.sortSetObject
			)
}
---------------------- FIN OBJSET ----------------


--------------------------------------------------------- TIMER Triggering OngoingRule
lazy rule CreateTimerOngoing{
	from
		rl : Behavior!Rule
	to
		timer : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidTimer,cteTimer,argsTimer}
			),
		oidTimer : Maude!Variable(
			name <- 'ACTEXEC@', --'TIMER@',
			type <- thisModule.sortOid
			),
		cteTimer : Maude!Constant(
			op <- 'OngoingActionExec@MGBehavior',
			type <- thisModule.sortAtActExec
			),
		argsTimer : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{actionTimer,maxDuration,startingTimer,endingTimer,participantsTimer,variablesTimer,upperBoundTimer}
			),
				
		-----action@ActionExec@MGBehavior
		
		actionTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{actionConst,actionVar}
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		actionVar : Maude!Constant(
			op <- '"'+ rl.name +'"',
			type <- thisModule.stringSort
			),
		
		-------status@AtomicActionExec@MGBehavior---------------
		
--		statusTimer : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{statusLeft,statusRight}
--			),
--		statusLeft : Maude!Constant(
--			op <- 'status@AtomicActionExec@MGBehavior',
--			type <- thisModule.sortAttribute
--			),
--		statusRight : Maude!Constant(
--			op <- 'unfinished@ActionStatus@MGBehavior',
--			type <- thisModule.actionStatusSort
--			),
			
		-----maxDuration@ActionExec@MGBehavior
		
		maxDuration : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{maxDurationConst,maxDurationFreeze}
			),
		maxDurationConst : Maude!Constant(
			op <- 'maxTimer@ActionExec@MGBehavior',--'maxDuration@OngoingActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		maxDurationFreeze : Maude!RecTerm(
			op <- thisModule.freezeOp,--'freeze', --'freeze(_)',
			type <- thisModule.oclTypeSort, --thisModule.intSort,
			args <- --maxDurationToRat
					if rl.maxDuration.oclIsUndefined() or rl.maxDuration='' then thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)
					else thisModule.allOclExpressions->any(i|rl.maxDuration=i.name).initExpression.oclExpConverter()--maxDurationValue
					endif
			),
			
		-----startingTime@ActionExec@MGBehavior	
		startingTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{startingConst,startingVar}
			),
		startingConst : Maude!Constant(
			op <- 'startingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		startingVar : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),

		------endingTime@ActionExec@MGBehavior	
		endingTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{endingConst,endingVar}
			),
		endingConst : Maude!Constant(
			op <- 'endingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		endingVar : Maude!Constant(
			op <- thisModule.nullOperator, --'undefined',
			type <- thisModule.oclTypeSort
			),
			
		---participants@ActionExec@MGBehavior
		participantsTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,setParticipants}					
			),	
		setParticipants : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsParticipants
			args <- if rl.objActExecLHSRule()->isEmpty() then
						thisModule.ConstantEmpty('')
					else
						if rl.objActExecLHSRule()->size()=1 then
							thisModule.OidOR('OR1@')--thisModule.ParticipantsOne(rl)}
						else
							thisModule.ParticipantsMany(rl,false)
						endif
					endif
			),
--		itemsParticipants : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <-
--					if rl.objActExecLHSRule()->isEmpty() then
--						thisModule.ConstantEmpty('')
--					else
--						if rl.objActExecLHSRule()->size()=1 then
--							thisModule.OidOR('OR1@')--thisModule.ParticipantsOne(rl)}
--						else
--							thisModule.ParticipantsMany(rl,false)
--						endif
--					endif
--			),		
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet--rl.LHSRule().oidOfORType() --thisModule.sortRefSimple 
			),
			
		---variables@ActionExec@MGBehavior
		variablesTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{variablesConst,setVariables}
			),
--		setVariables : Maude!RecTerm(
--			op <- thisModule.setCollection,
--			type <- thisModule.setSort,
--			args <-	thisModule.ConstantEmpty('')
--			),
		setVariables : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			args <-	if rl.vbles->isEmpty() then
						thisModule.ConstantEmpty('')
					else
						if rl.vbles->size()=1 then
							thisModule.OidOR('VAR1@')
						else
							thisModule.variablesMany(rl.vbles)
						endif
					endif
			),
		variablesConst : Maude!Constant(
			op <- 'variables@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet--rl.LHSRule().oidOfORType() --thisModule.sortRefSimple 
			),
			
		---upperBOUNDtIMER@ActionExec@MGBehavior	
		upperBoundTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{upperConst,upperVar}
			),
		upperConst : Maude!Constant(
			op <- 'upperBoundTimer@OngoingActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		upperVar : Maude!Constant(
			op <- thisModule.nullOperator, --'undefined',
			type <- thisModule.oclTypeSort
			)
}




--------------------------- TIMER Triggering ------------------------------------------------
-- Crea el objeto Action Execution que servir� como disparador de la regla
-- Programa la aplicacion de la acci�n de la regla

lazy rule CreateTimer{
	from
		rl : Behavior!AtomicRule
	to
		timer : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidTimer,cteTimer,argsTimer}
			),
		oidTimer : Maude!Variable(
			name <- 'ACTEXEC@', --'TIMER@',
			type <- thisModule.sortOid
			),
		cteTimer : Maude!Constant(
			op <- 'AtomicActionExec@MGBehavior',
			type <- thisModule.sortAtActExec
			),
		argsTimer : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{actionTimer,minTimer,maxTimer,executionTime,statusTimer,durationTimer,startTimeTimer,participantsTimer,variablesTimer}
			),
				
		-------action@ActionExec@MGBehavior----------		
		actionTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{actionConst,actionVar}
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		actionVar : Maude!Constant(
			op <- '"'+ rl.name +'"',
			type <- thisModule.stringSort
			),
			
--		-----timer@ActionExec@MGBehavior-------------
--		
--		timerTimer : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{timerConst,timerVar}
--			),
--		timerConst : Maude!Constant(
--			op <- 'timer@AtomicActionExec@MGBehavior',
--			type <- thisModule.sortAttribute
--			),	
--		timerVar : Maude!Variable(
--			name <- 'DURATION@',
--			type <- thisModule.timeInfSort
--			),

		-----minTimer@ActionExec@MGBehavior-------------
		
		minTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- if rl.minDuration.oclIsUndefined() or rl.minDuration='' then
						Sequence{minTimerConst,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}
					else
						Sequence{minTimerConst,thisModule.CreateVariable('MINDURATION@',thisModule.timeSort)} --thisModule.timeInfSort)}
					endif
			),
		minTimerConst : Maude!Constant(
			op <- 'minTimer@AtomicActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),	
--		minTimerVar : Maude!Variable(
--			name <- 'DURATION@',
--			type <- thisModule.timeInfSort
--			),
			

		-----maxTimer@ActionExec@MGBehavior-------------
		
		maxTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- if rl.maxDuration.oclIsUndefined() or rl.maxDuration='' then
						Sequence{maxTimerConst,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}
					else
						Sequence{maxTimerConst,thisModule.CreateVariable('MAXDURATION@',thisModule.timeSort)} --thisModule.timeInfSort)}
					endif
			),
		maxTimerConst : Maude!Constant(
			op <- 'maxTimer@ActionExec@MGBehavior',--'maxTimer@AtomicActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),	


		-----executionTime@ActionExec@MGBehavior-------------
		
		executionTime : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{execTimeConst,execTimeVar}
			),
		execTimeConst : Maude!Constant(
			op <- 'executionTime@AtomicActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),	
		execTimeVar : Maude!Constant(
			op <- '0',
			type <- thisModule.intSort
			),


		-------status@AtomicActionExec@MGBehavior---------------
		
		statusTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{statusLeft,statusRight}
			),
		statusLeft : Maude!Constant(
			op <- 'status@AtomicActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		statusRight : Maude!Constant(
			op <- 'unfinished@ActionStatus@MGBehavior',
			type <- thisModule.actionStatusSort
			),
			
		-----startingTime@ActionExec@MGBehavior------
		durationTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{durationConst,durationVar}
			),
		durationConst : Maude!Constant(
			op <- 'startingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		durationVar : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),

		------endingTime@ActionExec@MGBehavior-------
		startTimeTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{startTimeConst,startTimeVar}
			),
		startTimeConst : Maude!Constant(
			op <- 'endingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		startTimeVar : Maude!Constant(
			op <- thisModule.nullOperator, --'undefined',
			type <- thisModule.oclTypeSort
			),
			
		---participants@ActionExec@MGBehavior--------
		participantsTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,setParticipants}					
			),
		setParticipants : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsParticipants
			args <- if rl.objActExecLHSRule()->isEmpty() then 
						thisModule.ConstantEmpty('')
					else
						if rl.objActExecLHSRule()->size()=1 then
							thisModule.OidOR('OR1@')
						else
							thisModule.ParticipantsMany(rl,false)
						endif
					endif
			),
--		itemsParticipants : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <-	--if rl.objectsLHSRule()->isEmpty() then
--					if rl.objActExecLHSRule()->isEmpty() then 
--						thisModule.ConstantEmpty('')
--					else
--						--if rl.objectsLHSRule()->size()=1 then
--						if rl.objActExecLHSRule()->size()=1 then
--							thisModule.OidOR('OR1@')
--						else
--							thisModule.ParticipantsMany(rl,false)
--						endif
--					endif
--			),		
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet 
			),
			
		---variables@ActionExec@MGBehavior
		variablesTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{variablesConst,setVariables}
			),
		setVariables : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsVar
			args <-	if rl.vbles->isEmpty() then
						thisModule.ConstantEmpty('')
					else
						if rl.vbles->size()=1 then
							thisModule.OidOR('VAR1@')
						else
							thisModule.variablesMany(rl.vbles)
						endif
					endif
			),
--		itemsVar : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type<- thisModule.itemListSort,
--			args <-	if rl.vbles->isEmpty() then
--						thisModule.ConstantEmpty('')
--					else
--						if rl.vbles->size()=1 then
--							thisModule.OidOR('VAR1@')
--						else
--							thisModule.variablesMany(rl.vbles)
--						endif
--					endif				
--			),
		variablesConst : Maude!Constant(
			op <- 'variables@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet--rl.LHSRule().oidOfORType() --thisModule.sortRefSimple 
			)
}


-----------------------REGLAS AUXILIARES---------------------------------

------ Regla auxiliar para crear una constante 'mt' cuando sea necesario ------			
lazy rule ConstantEmpty{
	from
		blank : String
	to
		cte : Maude!Constant(
			op <- thisModule.mtOperator, --'mt'	
			type <- thisModule.mSetSort --thisModule.listSort
		)
}


-- Regla auxiliar para crear variables que representan Object Role (OR)---
lazy rule OidOR{
	from
		o : String	
	to
		d : Maude!Variable(
			name <- o,
			type <- thisModule.sortOid
			)
}

lazy rule ParticipantsMany{
	from
		rl : Behavior!Rule,
		isRHS : Boolean
	to
		participantsRT : Maude!RecTerm(
			op <- thisModule.mSetOperator, -- '_;_'
			type <- thisModule.mSetSort,--thisModule.listSort, 
			args <- Sequence{}
			)
	do{ 
		--for (p in rl.objectsLHSRule()){
		for (p in rl.objActExecLHSRule()){
				thisModule.counterTimerPre <- thisModule.counterTimerPre +1;
				participantsRT.args <- participantsRT.args -> append(thisModule.OidOR('OR'+ thisModule.counterTimerPre.toString()+'@'));
		}
		if (isRHS){
			--for (r in rl.NewObjectsRHS()){
			for (r in rl.NewObjActExecRHS()){
				thisModule.counterTimerPre <- thisModule.counterTimerPre +1;
				participantsRT.args <- participantsRT.args -> append(thisModule.OidOR('OR'+ thisModule.counterTimerPre.toString()+'@'));
			}
		}
		thisModule.counterTimerPre <- 0;
	}
}
	




lazy rule variablesMany{
	from
		var : Sequence(Behavior!Variable)
	to
		variablesRT : Maude!RecTerm(
			op <- thisModule.mSetOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.mSetSort, --thisModule.listSort, 
			args <- Sequence{}
			)
	do{
		for (p in var){
				thisModule.counterTimerPre <- thisModule.counterTimerPre +1;
				variablesRT.args <- variablesRT.args -> append(thisModule.OidOR('VAR'+ thisModule.counterTimerPre.toString()+'@'));
			}
		thisModule.counterTimerPre <- 0;
	}
}


------------------------- FIN REGLAS AUXILIARES -----------------------------------



---------------------------------- TIMER REALIZATION ---------------------------------------
--Crea el TIMER en la REALIZATION RULE de las ATOMIC RULES
--Crea el TIMER en las ONGOING RULES
--Crea el TIMER de la REALIZATION RULE. En lhs de la regla Maude el timer se pone a 0
--En la REALIZATION RULE, en rhs(Maude): se asigna a 'endingTime' el valor de TIME@CLK@
--		y en caso de q la regla cree nuevos objetos se a�aden como 'participants'
--Crea el TIMER en la INSTANTANEOUS RULEs
lazy rule CreateTimerRealization{
	from
		rl : Behavior!Rule,
		isRHS : Boolean
	to
		timer : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidTimer,cteTimer,argsTimer}
			),
		oidTimer : Maude!Variable(
			name <- 'ACTEXEC@', --'TIMER@',
			type <- thisModule.sortOid
			),
		cteTimer : Maude!Constant(
			op <- if rl.oclIsTypeOf(Behavior!AtomicRule) then 'AtomicActionExec@MGBehavior'
					else 'OngoingActionExec@MGBehavior'
					endif,
			type <- thisModule.sortAtActExec
			),
		argsTimer : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- -- Los elementos del Timer ser�n diferentes seg�n si la regla es AtomicRule u OngoingRule
					-- En las AtomicRule se distingue entre Reglas Instant�neas(duratio=0) y el resto puesto que las Instant�neas 'ACTEXEC@'
					-- no llevan la variable TIMER@@SFS
					if rl.oclIsTypeOf(Behavior!AtomicRule) then
						if rl.minDuration='0' then 
							Sequence{actionTimer,thisModule.StatusFeature(isRHS),thisModule.MinMaxTimerFeature('minTimer@AtomicActionExec'),thisModule.MinMaxTimerFeature('maxTimer@ActionExec'),thisModule.StartingTimeFeatureInstantaneous(''),thisModule.ExecutionTimeFeature(''),endingTimer,participantsTimer,variablesTimer}
						else 
							if isRHS then
								Sequence{actionTimer,thisModule.StatusFeature(isRHS),thisModule.MinMaxTimerFeature('minTimer@AtomicActionExec'),endingTimer,participantsTimer,variablesTimer,thisModule.CreateVariable('ACTEXEC@@SFS',thisModule.sortSetSfi)} --thisModule.CreateVariable('TIMER@@SFS',thisModule.sortSetSfi)}--,sfeat}
							else
								Sequence{actionTimer,thisModule.StatusFeature(isRHS),thisModule.MinMaxTimerFeature('minTimer@AtomicActionExec'),endingTimer,thisModule.ExecutionTimeFeature(''),participantsTimer,variablesTimer,thisModule.CreateVariable('ACTEXEC@@SFS',thisModule.sortSetSfi)} --thisModule.CreateVariable('TIMER@@SFS',thisModule.sortSetSfi)}--,sfeat}
							endif
						endif
					else
						if isRHS then 
							Sequence{actionTimer,endingTimer,participantsTimer,variablesTimer,thisModule.EvalMaxDurationFeature(''),thisModule.CreateVariable('ACTEXEC@@SFS',thisModule.sortSetSfi)} --thisModule.CreateVariable('TIMER@@SFS',thisModule.sortSetSfi)}--,sfeat}
						else 
							Sequence{actionTimer,endingTimer,participantsTimer,variablesTimer,thisModule.MaxDurationFeature(''),thisModule.CreateVariable('ACTEXEC@@SFS',thisModule.sortSetSfi)} --thisModule.CreateVariable('TIMER@@SFS',thisModule.sortSetSfi)}--,sfeat}
						endif
					endif			
			),
			
		-----action@ActionExec@MGBehavior--------
		actionTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{actionConst,actionValue}
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		actionValue : Maude!Constant(
			op <- '"'+ rl.name +'"',
			type <- thisModule.stringSort
			),
		---------------------------------------------
		-------status@AtomicActionExec@MGBehavior---------------
		
--		status : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{statusLeft,statusRight}
--			),
--		statusLeft : Maude!Constant(
--			op <- 'status@AtomicActionExec@MGBehavior',
--			type <- thisModule.sortAttribute
--			),
--		statusRight : Maude!Constant(
--			op <- if isRHS then 'realized@ActionStatus@MGBehavior'
--				else 'unfinished@ActionStatus@MGBehavior'
--				endif,
--			type <- thisModule.actionStatusSort
--			),

		-------endingTime@ActionExec@MGBehavior------
		endingTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- if rl.oclIsTypeOf(Behavior!OngoingRule) and isRHS then Sequence{endingConst,thisModule.EndingOngoingFeature('')} 
					else 
						if isRHS then Sequence{endingConst,thisModule.EndingValueVar(isRHS)}
						else Sequence{endingConst,thisModule.EndingValueConst(isRHS)}
						endif
					endif
			),
		endingConst : Maude!Constant(
			op <- 'endingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		-----------------------------------------------	
		
		------participants@ActionExec@MGBehavior-------			
		participantsTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,setParticipants}					
			),	
		setParticipants : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsParticipants
			args <-	if isRHS then
						if rl.objActExecLHSRule()->isEmpty() and rl.NewObjActExecRHS()->isEmpty() then
							thisModule.ConstantEmpty('')
						else
							if rl.objActExecLHSRule()->size()+rl.NewObjActExecRHS()->size()=1 then 
								thisModule.OidOR('OR1@')
							else
								thisModule.ParticipantsMany(rl,isRHS)
							endif
						endif
					else
						if rl.objActExecLHSRule()->isEmpty() then
							thisModule.ConstantEmpty('')
						else
							if rl.objActExecLHSRule()->size()=1 then
								thisModule.OidOR('OR1@')
							else
								thisModule.ParticipantsMany(rl,isRHS)
							endif
						endif
					endif
			),
--		itemsParticipants : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 
--					if isRHS then
--						if rl.objActExecLHSRule()->isEmpty() and rl.NewObjActExecRHS()->isEmpty() then
--							thisModule.ConstantEmpty('')
--						else
--							if rl.objActExecLHSRule()->size()+rl.NewObjActExecRHS()->size()=1 then 
--								thisModule.OidOR('OR1@')
--							else
--								thisModule.ParticipantsMany(rl,isRHS)
--							endif
--						endif
--					else
--						if rl.objActExecLHSRule()->isEmpty() then
--							thisModule.ConstantEmpty('')
--						else
--							if rl.objActExecLHSRule()->size()=1 then
--								thisModule.OidOR('OR1@')
--							else
--								thisModule.ParticipantsMany(rl,isRHS)
--							endif
--						endif
--					endif
--			),		
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet 
			),			
		-------------------------------------------------

		---variables@ActionExec@MGBehavior
		variablesTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{variablesConst,setVariables}
			),
		setVariables : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsVar
			args <-	if rl.vbles->isEmpty() then
						thisModule.ConstantEmpty('')
					else
						if rl.vbles->size()=1 then
							thisModule.OidOR('VAR1@')
						else
							thisModule.variablesMany(rl.vbles)
						endif
					endif
			),
--		itemsVar : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type<- thisModule.itemListSort,
--			args <-	if rl.vbles->isEmpty() then
--						thisModule.ConstantEmpty('')
--					else
--						if rl.vbles->size()=1 then
--							thisModule.OidOR('VAR1@')
--						else
--							thisModule.variablesMany(rl.vbles)
--						endif
--					endif				
--			),
		variablesConst : Maude!Constant(
			op <- 'variables@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet 
			)	
}
	
	lazy rule ExecutionTimeFeature{
		from
			blank : String
		to
			executionTime : Maude!RecTerm(
				op <- thisModule.sfsOperator, -- '_:_'
				type <- thisModule.sortRefInst,
				args <- Sequence{execTimeConst,execTimeVar}
				),
			execTimeConst : Maude!Constant(
				op <- 'executionTime@AtomicActionExec@MGBehavior',
				type <- thisModule.sortAttribute
				),	
			execTimeVar : Maude!Variable(
				name <- 'T',
				type <- thisModule.oclTypeSort
				)
	}
	
	
	lazy rule StartingTimeFeatureInstantaneous{
		from
			blank : String
		to
			startingTimer : Maude!RecTerm(
				op <- thisModule.sfsOperator, -- '_:_'
				type <- thisModule.sortRefInst,
				args <- Sequence{startingConst,startingVar}
				),
			startingConst : Maude!Constant(
				op <- 'startingTime@ActionExec@MGBehavior',
				type <- thisModule.sortAttribute
				),
			startingVar : Maude!Variable(
				name <- 'TIME@CLK@',
				type <- thisModule.timeSort --thisModule.timeInfSort
				)
	}	
	

	
	lazy rule StatusFeature{
		from
			isRHS : Boolean
		to
			status : Maude!RecTerm(
				op <- thisModule.sfsOperator, -- '_:_'
				type <- thisModule.sortRefInst,
				args <- Sequence{statusLeft,statusRight}
				),
			statusLeft : Maude!Constant(
				op <- 'status@AtomicActionExec@MGBehavior',
				type <- thisModule.sortAttribute
				),
			statusRight : Maude!Constant(
				op <- if isRHS then 'realized@ActionStatus@MGBehavior'
					else 'unfinished@ActionStatus@MGBehavior'
					endif,
				type <- thisModule.actionStatusSort
				)
	}	
	
		

	lazy rule EndingOngoingFeature{
		from
			blank : String
		to
			plus : Maude!RecTerm(
				op <- thisModule.plusOp,
				type <- thisModule.timeSort, --thisModule.timeInfSort,
				args <- Sequence{varLeft,varRight}
				),
			varLeft : Maude!Variable(
				name <- 'TIME@CLK@',
				type <- thisModule.timeSort -- thisModule.timeInfSort
				),
			varRight : Maude!Variable(
				name <- 'T',
				type <- thisModule.oclTypeSort --thisModule.timeInfSort
				)
	}

	-- Estas dos reglas crean el valor de la feature endingTime@ActionExec@MGBehavior
	-- Se crean dos reglas que crearan segun el caso una Variable o una Constante
	lazy rule EndingValueVar{
		from
			isRHS : Boolean --(isRHS)
		to
			endingValue : Maude!Variable(
				name <- 'TIME@CLK@',
				type <- thisModule.timeSort --thisModule.timeInfSort					
				)
	}
	
	lazy rule EndingValueConst{
		from
			isRHS : Boolean --(not isRHS)
		to
			endingValue : Maude!Constant(
				op <- thisModule.nullOperator, --'undefined',
				type <- thisModule.oclTypeSort
				)
	}
--------------------------------------------------------------------------------

	----------Crea la feature timer@AtomicActionExec@MGBehavior del TIMER-----------
	-- se crea en una regla auxiliar porque la regla del timer se utiliza tambien para
	-- las OngoingRules que no llevan esta feature
	
	lazy rule MinMaxTimerFeature{
		from
			feat : String
		to
			timerTimer : Maude!RecTerm(
				op <- thisModule.sfsOperator, -- '_:_'
				type <- thisModule.sortRefInst,
				args <- Sequence{timerConst,timerValue}
				),
			timerConst : Maude!Constant(
				op <- --'minTimer@AtomicActionExec@MGBehavior',
						feat+'@MGBehavior',
				type <- thisModule.sortAttribute
				),
			timerValue : Maude!Constant(
				op <- '0',
				type <- thisModule.intSort
				)
	}
	---------------------------------------------------------------------------------

	lazy rule MaxDurationFeature{
		from
			blank : String			
		to
			maxDuration : Maude!RecTerm(
				op <- thisModule.sfsOperator, -- '_:_'
				type <- thisModule.sortRefInst,
				args <- Sequence{maxConst,freeze}
				),
			maxConst : Maude!Constant(
				op <- 'maxTimer@ActionExec@MGBehavior',--'maxDuration@OngoingActionExec@MGBehavior',
				type <- thisModule.sortAttribute
				),
			freeze : Maude!RecTerm(
				op <- thisModule.freezeOp, --'freeze', --'freeze(_)',
				type <- thisModule.oclTypeSort, --thisModule.intSort,
				args <- maxValue
				),
			maxValue : Maude!Variable(
				name <- 'MAXDURATIONONGOING@', --MAXDURATION@,						
				type <- thisModule.oclExpSort --thisModule.oclExpSort
				)		
	}

	lazy rule EvalMaxDurationFeature{
		from
			blank : String
		to
			maxDuration : Maude!RecTerm(
				op <- thisModule.sfsOperator, -- '_:_'
				type <- thisModule.sortRefInst,
				args <- Sequence{maxConst,toRat}
				),
			maxConst : Maude!Constant(
				op <- 'maxTimer@ActionExec@MGBehavior',--'maxDuration@OngoingActionExec@MGBehavior',
				type <- thisModule.sortAttribute
				),
			toRat : Maude!RecTerm(
				op <- thisModule.toRatOperator,
				type <- thisModule.ratSort,
				args <- eval
				),
			eval : Maude!RecTerm(
				op <- thisModule.evalOperator,
				type <- thisModule.oclExpSort,
				args <- Sequence{maxValue,env,model}
				),		
			maxValue : Maude!Variable(
				name <- 'MAXDURATIONONGOING@',--'MAXDURATION@',
				type <- thisModule.oclExpSort
				),
			env : Maude!RecTerm(
				op <- thisModule.envOperator,
				type <- thisModule.msgSort,
				args <- emptyArg
				),
			emptyArg : Maude!Constant(
				op <- thisModule.emptyOperator,
				type <- thisModule.emptySetSort
				),
			model : Maude!Variable(
				name <- 'MODEL@',
				type <- thisModule.sortModel
				)
	}
	
	------------------------------------------------------- FIN Timer REALIZATION


--------------------------------------------------------- Ongoing Action Execution Element
lazy rule CreateTimerCurrentExec{
	from
		rl : Behavior!Rule
	to
		timer : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidTimer,cteTimer,argsTimer}
			),
		oidTimer : Maude!Variable(
			name <- 'ACTEXEC@', --'TIMER@',
			type <- thisModule.sortOid
			),
		cteTimer : Maude!Constant(
			op <- if rl.oclIsTypeOf(Behavior!AtomicRule) then 'AtomicActionExec@MGBehavior'
					else 'OngoingActionExec@MGBehavior'
					endif,
			type <- thisModule.sortAtActExec
			),
		argsTimer : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{actionTimer,endingTimer,participantsTimer,sfeat}
			),
			
		actionTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{actionConst,actionValue}
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		actionValue : Maude!Constant(
			op <- '"'+ rl.name +'"',
			type <- thisModule.stringSort
			),		
			
		endingTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{endingConst,endingValue}
			),
		endingConst : Maude!Constant(
			op <- 'endingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		endingValue : Maude!Constant(
			op <- thisModule.nullOperator, --'undefined',
			type <- thisModule.oclTypeSort
			),
			
		participantsTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,set}
			),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if rl.objActExecLHSRule()->isEmpty() then participantsVar
					else thisModule.ParticipantsManyAlreadyCurrentCondition(rl,participantsVar)
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 
--					if rl.objActExecLHSRule()->isEmpty() then
--						participantsVar
--					else
--						--thisModule.ParticipantsMany(rl,false)
--						thisModule.ParticipantsManyAlreadyCurrentCondition(rl,participantsVar)
--					endif
----					if rl.objActExecLHSRule()->isEmpty() then
----						thisModule.ConstantEmpty('')
----					else
----						if rl.objActExecLHSRule()->size()=1 then
----							thisModule.OidOR('OR1@')
----						else
----							thisModule.ParticipantsMany(rl,false)--thisModule.ParticipantsMany(rl.lhs)
----						endif
----					endif
--			),
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet--rl.LHSRule().oidOfORType() --thisModule.sortRefSimple 
			),
		participantsVar : Maude!Variable(
			name <- 'L@ACTEXEC@', --'L@TIMER@',
			type <- thisModule.mSetSort --thisModule.listSort
			),	
		sfeat : Maude!Variable(
			name <- 'ACTEXEC@@SFS', --'TIMER@@SFS',
			type <- thisModule.sortSetSfi
			)
}



lazy rule CreateTimerAlready{
	from
		rl : Behavior!Rule
	to
		timer : Maude!RecTerm(
			op <- thisModule.objectOperator,
			type <- thisModule.sortObject,
			args <- Sequence{oidTimer,cteTimer,argsTimer}
			),
		oidTimer : Maude!Variable(
			name <- 'ACTEXEC@', --'TIMER@',
			type <- thisModule.sortOid
			),
		cteTimer : Maude!Constant(
			op <- 'AtomicActionExec@MGBehavior',
			type <- thisModule.sortAtActExec
			),
		argsTimer : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{actionTimer,startingTimer,participantsTimer,sfeat}
			),
			
		actionTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{actionConst,actionValue}
			),
		actionConst : Maude!Constant(
			op <- 'action@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		actionValue : Maude!Constant(
			op <- '"'+ rl.name +'"',
			type <- thisModule.stringSort
			),		
			
		startingTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{startingConst,startingValue}
			),
		startingConst : Maude!Constant(
			op <- 'startingTime@ActionExec@MGBehavior',
			type <- thisModule.sortAttribute
			),
		startingValue : Maude!Variable(
			name <- 'STARTINGTIME@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),
			
		participantsTimer : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{participantsConst,set}
			),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if rl.objActExecLHSRule()->isEmpty() then participantsVar
					else thisModule.ParticipantsManyAlreadyCurrentCondition(rl,participantsVar)
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 
--					if rl.objActExecLHSRule()->isEmpty() then
--						participantsVar
--					else
--						--thisModule.ParticipantsMany(rl,false)
--						thisModule.ParticipantsManyAlreadyCurrentCondition(rl,participantsVar)
--					endif
--			
----					if rl.objActExecLHSRule()->isEmpty() then
----						thisModule.ConstantEmpty('')
----					else
----						if rl.objActExecLHSRule()->size()=1 then
----							thisModule.OidOR('OR1@')
----						else
----							thisModule.ParticipantsMany(rl,false) --thisModule.ParticipantsMany(rl.lhs)
----						endif
----					endif
--			),
		participantsConst : Maude!Constant(
			op <- 'participants@ActionExec@MGBehavior',
			type <- thisModule.sortOidSet--rl.LHSRule().oidOfORType() --thisModule.sortRefSimple 
			),
		participantsVar : Maude!Variable(
			name <- 'L@ACTEXEC@', --'L@TIMER@',
			type <- thisModule.mSetSort --thisModule.listSort
			),
		sfeat : Maude!Variable(
			name <- 'ACTEXEC@@SFS', --'TIMER@@SFS',
			type <- thisModule.sortSetSfi
			)
}

lazy rule ParticipantsManyAlreadyCurrentCondition{
	from
		rl : Behavior!Rule,
		--isRHS : Boolean
		lTimer : Maude!Variable
	to
		participantsRT : Maude!RecTerm(
			op <- thisModule.mSetOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.mSetSort, --thisModule.listSort, 
			args <- Sequence{lTimer}
			)
	do{ 
		--for (p in rl.objectsLHSRule()){
		for (p in rl.objActExecLHSRule()){
				thisModule.counterTimerPre <- thisModule.counterTimerPre +1;
				participantsRT.args <- participantsRT.args -> append(thisModule.OidOR('OR'+ thisModule.counterTimerPre.toString()+'@'));
		}
--		if (isRHS){
--			--for (r in rl.NewObjectsRHS()){
--			for (r in rl.NewObjActExecRHS()){
--				thisModule.counterTimerPre <- thisModule.counterTimerPre +1;
--				participantsRT.args <- participantsRT.args -> append(thisModule.OidOR('OR'+ thisModule.counterTimerPre.toString()+'@'));
--			}
--		}
		thisModule.counterTimerPre <- 0;
	}
}


---Regla para crear los objetos 'ORi' que representan los objetos que participan en la regla----

lazy rule CreateObjRole{
	from
		--ob : Behavior!Object,
		ob : Behavior!PatternEl,
		cont : Integer		
	to
		obRole : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <-	Sequence{id,objClass,argms}
			),
		id : Maude!Variable(
			name <- 'OR'+cont.toString()+'@',
			type <- thisModule.sortOid
			),
		objClass : Maude!Constant(
			op <- 'ObjectRole@MGBehavior',
			type <- thisModule.sortObjRole
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{obj,objR}
			),
		obj : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{constObj,varObj}
			),
		constObj : Maude!Constant(
			op <-  'actualObject@ObjectRole@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		varObj : Maude!Variable(
			name <- ob.id,
			type <- thisModule.oclTypeSort
			),
		objR : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{constObjR,varObjR}
			),
		constObjR : Maude!Constant(
			op <-  'role@ObjectRole@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		varObjR : Maude!Constant(
			op <- '"'+ob.id+'"',
			type <- thisModule.stringSort
			)
}
-----------------------------------------------------------------------


---Regla para crear los objetos 'VARi' que representan los variables que participan en la regla----
lazy rule CreateVar{
	from
		var : Behavior!Variable,
		cont : Integer		
	to
		obRole : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <-	Sequence{id,varClass,argms}
			),
		id : Maude!Variable(
			name <- 'VAR'+cont.toString()+'@',
			type <- thisModule.sortOid
			),
		varClass : Maude!Constant(
			op <- 'Variable@MGBehavior',
			type <- thisModule.variableSort
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{name,value}
			),
		name : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{nameIzq,nameDer}
			),
		nameIzq : Maude!Constant(
			op <-  'name@Variable@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		nameDer : Maude!Constant(
			op <- '"'+var.name.toString()+'"',
			type <- thisModule.stringSort
			),
		value : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{valueIzq,valueDer}
			),
		valueIzq : Maude!Constant(
			op <-  'value@Variable@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		valueDer : Maude!Variable(
			name <- var.name.toString(),
			type <- thisModule.oclTypeSort
			)
}
-------------------------------------------------------------------------------

---Regla para crear los objetos 'VARi' que representan los variables que participan en la regla----
lazy rule CreateFreezeVarApply{
	from
		var : Behavior!Variable,
		cont : Integer		
	to
		obRole : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <-	Sequence{id,varClass,argms}
			),
		id : Maude!Variable(
			name <- 'VAR'+cont.toString()+'@',
			type <- thisModule.sortOid
			),
		varClass : Maude!Constant(
			op <- 'Variable@MGBehavior',
			type <- thisModule.variableSort
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{name,value}
			),
		name : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{nameIzq,nameDer}
			),
		nameIzq : Maude!Constant(
			op <-  'name@Variable@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		nameDer : Maude!Constant(
			op <- '"'+var.name.toString()+'"',
			type <- thisModule.stringSort
			),
		value : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{valueIzq,freeze}
			),
		valueIzq : Maude!Constant(
			op <-  'value@Variable@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		freeze : Maude!RecTerm(
			op <- thisModule.freezeOp,
			type <- thisModule.oclTypeSort,
			args <- valueDer
			),
		valueDer : Maude!Variable(
			name <- var.name.toString()+'@UNVALUED',
			type <- thisModule.oclExpSort
			)
}
-------------------------------------------------------------------------------

---Regla para crear los objetos 'VARi' que representan los variables que participan en la regla----
lazy rule CreateFreezeVarOngoing{
	from
		var : Behavior!Variable,
		cont : Integer		
	to
		obRole : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <-	Sequence{id,varClass,argms}
			),
		id : Maude!Variable(
			name <- 'VAR'+cont.toString()+'@',
			type <- thisModule.sortOid
			),
		varClass : Maude!Constant(
			op <- 'Variable@MGBehavior',
			type <- thisModule.variableSort
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- Sequence{name,value}
			),
		name : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{nameIzq,nameDer}
			),
		nameIzq : Maude!Constant(
			op <-  'name@Variable@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		nameDer : Maude!Constant(
			op <- '"'+var.name.toString()+'"',
			type <- thisModule.stringSort
			),
		value : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{valueIzq,freeze}
			),
		valueIzq : Maude!Constant(
			op <-  'value@Variable@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		freeze : Maude!RecTerm(
			op <- thisModule.freezeOp,
			type <- thisModule.oclTypeSort,
			args <- valueDer
			),
		valueDer : Maude!Variable(
			name <- var.name.toString(),
			type <- thisModule.oclExpSort
			)
}




------------------------------------------------------------------------------------------------------------------------------
----------------------------Reglas para los OBJETOS---------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------


----------------- Transforma OBJETOS en TERMINOS RECURSIVOS ---------------------------------------
--Transforma los Objetos del patr�n LHS y los de RHS
--Se diferencia entre LHS y RHS porque en RHS los Slots y Links aparecen computados
lazy rule Object2RecTerm{
	from
		obj : Behavior!Object,
		p : Behavior!Pattern
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <-	if p.isRHSPattern() then					
						Sequence{id,objClass,
							if (obj.outLinks -> isEmpty() and 
								obj.OppositeLinks()->isEmpty() and 
								obj.sfs -> isEmpty() and 
								obj.getLHSDeletedLinksFromRHSObject()->isEmpty() and 
								obj.OppositeLHSLinksNiIni()->isEmpty() ) then 
								sfeat
							else 
								thisModule.ObjectArgmsRHS(p,obj,sfeat)
							endif
							}
					else
						Sequence{id,objClass,
							if ((obj.outLinks -> isEmpty() and obj.OppositeLinks()->isEmpty())and(obj.sfs -> isEmpty())) then sfeat
							else thisModule.ObjectArgmsLHS(p,obj,sfeat) 							
							endif
							}
					endif						
			),
		id : Maude!Variable(
			name <- obj.id,
			type <- thisModule.oclTypeSort
			),
		objClass : Maude!Variable(
			name <- obj.classGD.class.maudeName().toUpper()+'@'+obj.id+'@CLASS',
			type <- thisModule.Class2Sort(obj.classGD.class)
			),
		sfeat : Maude!Variable(
			name <- obj.id + '@SFS',
			type <- thisModule.sortSetSfi
			)
}



----------------- Transforma OBJETOS en TERMINOS RECURSIVOS ---------------------------------------
--Transforma los Objetos del patr�n RHS que no est�n presentes en LHS
--Estos objetos van a tener una regla espec�fica porque la clase del objeto ya no va a venir dada por una variable sino
--por una constante debido a que el objeto lo creamos nosotros, no es un patr�n.
--Adem�s estos objetos no tendr�n un elemento SFS que represente las Structural Features del objeto
lazy rule NewObjectRHS2RecTerm{
	from
		obj : Behavior!Object,
		p : Behavior!Pattern
	to
		cmplt : Maude!RecTerm(
			op <- thisModule.completeOp,
			type <- thisModule.sortObject,
			args <- rt
			),
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <-	Sequence{id,objClass,
					if ((obj.outLinks -> isEmpty() and obj.OppositeLinks()->isEmpty())and(obj.sfs -> isEmpty())) then thisModule.CreateConstant('empty',thisModule.attributeSetSort)
					else
						if (obj.outLinks -> isEmpty() and obj.OppositeLinks()->isEmpty())and(obj.sfs->size()=1) then thisModule.Slots2RecTermRHS(obj.sfs->first())
						else
							if (obj.sfs -> isEmpty())and thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())->size()=1 then --(obj.outLinks->size()=1) then 
								--thisModule.LinksAddRefRHS(obj.outLinks->first())
								--thisModule.RefWithoutDuplicates(obj.outLinks)->collect(r|thisModule.LinksUpdate(r,obj,true))
								thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())-> collect(r|thisModule.LinksUpdate(r,obj,true))
							else thisModule.NewObjectArgmsRHS(obj)
							endif
						endif						
					endif
					}			
					),
		id : Maude!Variable(
			name <- obj.id,
			type <- thisModule.oclTypeSort
			),
		objClass : Maude!Constant(
			op <- obj.classGD.class.maudeName(),
			type <- thisModule.Class2Sort(obj.classGD.class)
			)
}

--A partir de un objeto de LHS devuelve los links de ese objeto que estan en LHS
--y no est�n en RHS (suponiendo que el objeto este tambien en RHS)
helper context Behavior!Object def : getLHSDeletedLinksFromLHSObject():Sequence(Behavior!Link)=
	self.outLinks->select(j| if self.SameObjInRHS().oclIsUndefined() then false
							else not self.SameObjInRHS().outLinks->exists(i|i.ref=j.ref) -- and i.src=j.src and i.target=j.target)
							endif)							
;




helper context Behavior!Object def : getLHSDeletedLinksFromRHSObject():Sequence(Behavior!Link)=
	if self.SameObjInLHS().oclIsUndefined() then Sequence{}
	else
		self.SameObjInLHS().outLinks->select(j|not self.outLinks->exists(i|i.ref=j.ref))
	endif
;



----------------Crea los OBJECTS en lhs(Maude) de la Realization Rule----------------------------------------------
--Se crean los objetos de LHS con Structural Features (atributos o referencias) que ser�n computados
--Esos Structural Features no se computan en la condici�n sino en rhs de la regla Maude

lazy rule Object2RecTermRealization{
	from
		obj : Behavior!Object,
		p : Behavior!Pattern
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <- --Se comprueba se el objeto esta en la parte derecha y si en la parte derecha tiene slots o links
					--hay que comprobarlo porque si no tiene structural features no hay que a�adir el operador '_`,_'
					Sequence{id,objClass,
					if ((obj.existObjInRHS(p)) and (p.getSlotsRHS(obj)->notEmpty() or
													p.getLinksRHS(obj)->notEmpty() or
													obj.getOppositeLinksRHS()->notEmpty() or										
													obj.getLHSDeletedLinksFromLHSObject()->notEmpty() or
													obj.OppositeRHSLinksNiIni()->notEmpty() ))then
													
							thisModule.ObjectArgmsLhsRealization(p,obj,sfeat)							
					else sfeat
					endif
					}								
			),
		id : Maude!Variable(
			name <- obj.id,
			type <- thisModule.oclTypeSort
			),
		objClass : Maude!Variable(
			name <- obj.classGD.class.maudeName().toUpper()+'@'+obj.id+'@CLASS',
			type <- thisModule.Class2Sort(obj.classGD.class)
			),
		sfeat : Maude!Variable(
			name <- obj.id + '@SFS',
			type <- thisModule.sortSetSfi
			)

}


--------------lhs Objects of Equation ApplyOngoing-----------------------------
lazy rule Object2RecTermApplyOngoingLHS{
	from
		obj : Behavior!Object,
		p : Behavior!Pattern
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <- Sequence{id,objClass,
					--existsStructFeatInRhs comprueba tambi�n que no existan links opuestos
					if (obj.existsStructFeat() or p.existsSFInRhs(obj)) then
							thisModule.ObjectArgmsLhsApplyOngoing(p,obj,sfeat)							
					else sfeat
					endif
					}									
			),
		id : Maude!Variable(
			name <- obj.id,--.toUpper(),
			type <- thisModule.oclTypeSort
			),
		objClass : Maude!Variable(
			name <- obj.classGD.class.maudeName().toUpper()+'@'+obj.id+'@CLASS',--obj.class.name,--obj.class.maudeClassifierName(), --obj.class.name,
			type <- thisModule.Class2Sort(obj.classGD.class)
			),
		sfeat : Maude!Variable(
			name <- obj.id + '@SFS',
			type <- thisModule.sortSetSfi
			)
}



--------------rhs Objects of Equation ApplyOngoing-----------------------------
lazy rule Object2RecTermApplyOngoingRHS{
	from
		obj : Behavior!Object,
		p : Behavior!Pattern -- aqui paso un RHS
	to
		rt : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,
			args <- Sequence{id,objClass,
					--if ((obj.existObjInRHS(p)) and (p.getSlotsRHS(obj)->notEmpty() or p.getLinksRHS(obj)->notEmpty()))then
					if (obj.existsStructFeat() or p.existsSFInLhs(obj)) then
							thisModule.ObjectArgmsRhsApplyOngoing(p,obj,sfeat)							
					else sfeat
					endif
					}									
			),
		id : Maude!Variable(
			name <- obj.id,--.toUpper(),
			type <- thisModule.oclTypeSort
			),
		objClass : Maude!Variable(
			name <- obj.classGD.class.maudeName().toUpper()+'@'+obj.id+'@CLASS',--obj.class.name,--obj.class.maudeClassifierName(), --obj.class.name,
			type <- thisModule.Class2Sort(obj.classGD.class)
			),
		sfeat : Maude!Variable(
			name <- obj.id + '@SFS',
			type <- thisModule.sortSetSfi
			)
}
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------




	

-------------------------------------------------------------------------------------------------------------------------
-----------------Reglas para los ARGUMENTOS DE OBJETOS-------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------


-------------------Crea los STRUCTURAL FEATURES de un Objeto del patr�n LHS----------------------------------------------
---------------y llama a la rule correspondiente seg�n sean Slots o Links
lazy rule ObjectArgmsLHS{
	from
		p : Behavior!Pattern,
		obj : Behavior!Object,
		sfeat : Maude!Variable
	to
		sfi : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <-	
					thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())-> collect(r|thisModule.Links2RecTerm(r,obj.id))->
					--thisModule.RefWithoutDuplicates(obj.outLinks) -> collect(r|thisModule.Links2RecTerm(r,obj.id))->
					union(obj.sfs -> collect(s|thisModule.Slots2RecTerm(s)))->
					append(sfeat)
					)
}

---------------Crea el conjunto de los STRUCTURAL FEATURES de un objeto RHS------------------------------------------------
--Se llama a la rule correspondiente seg�n sean Links o Slots
--Van a aparecer los atributos computados (Slots) y los Links creados 
lazy rule ObjectArgmsRHS{
	from
		p : Behavior!Pattern,
--		links : Sequence(Behavior!Link),
--		slots : Sequence(Behavior!Slot),
		obj : Behavior!Object,
		sfeat : Maude!Variable --paso esto como par�metro porque no puedo a�adirlo con resolveTemp
	to
		sfi : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
--			args <-	links -> collect(l|	thisModule.LinksAddRef(l)) ->							
--						union(slots -> collect(s|thisModule.Slots2RecTermRHS(s)))->									
--						append(sfeat)
--						)
			args <-	--thisModule.RefWithoutDuplicates(obj.outLinks)->collect(r|thisModule.LinksUpdate(r,obj,false))-> -- ->collect(r|thisModule.LinksUpdate(r,r.LinksWithConcreteRef(obj.outLinks),false))
					thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())-> collect(r|thisModule.LinksUpdate(r,obj,false))->
					--obj.outLinks -> collect(l|	thisModule.LinksAddRef(l)) ->							
						union(obj.sfs -> collect(s|thisModule.Slots2RecTermRHS(s)))->				
						
						--union(thisModule.RefWithoutDuplicates(p.getLHSLinksNoIni(obj))->collect(r|thisModule.LinksUpdateLHS(r,obj.SameObjInLHS())))->
						union(thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(p.getLHSLinksNoIni(obj)),obj.OppositeLHSLinksNiIni())-> collect(r|thisModule.LinksUpdateLHS(r,obj.SameObjInLHS())))->
						append(sfeat)
						)

}


helper context Behavior!Object def: OppositeLinksLHSandRHS(): Sequence(Behavior!EReference)=
	--self.SameObjInRHS().OppositeLinks()->union(self.OppositeLinks());
	if self.SameObjInRHS().oclIsUndefined() then self.OppositeLinks()
	else self.SameObjInRHS().OppositeLinks()->union(self.OppositeLinks())
	endif;

helper context Behavior!Pattern def : getLinksLHSandRHS(obj:Behavior!Object):Sequence(Behavior!Link)=
	obj.outLinks->union(self.getLinksRHS(obj));


--Regla para generar las Structural Features de un objeto del lhs(maude) de una Realization Rule-----

lazy rule ObjectArgmsLhsRealization{
	from
		p : Behavior!Pattern,
		obj : Behavior!Object,
		sfeat : Maude!Variable
	to
		sfi : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <-	--Se a�aden los slots y links de estos objetos presentes en RHS
					p.getSlotsRHS(obj)->collect(r|thisModule.Slots2RecTerm(r))->					
					--union(thisModule.LinksWithoutDuplicates(p.getLinksRHS(obj))->collect(n|thisModule.Links2RecTerm(n)))->
					--union(thisModule.RefWithoutDuplicates(p.getLinksRHS(obj)) -> collect(r|thisModule.Links2RecTerm(r,obj.id)))->
					union(thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(p.getLinksLHSandRHS(obj)),obj.OppositeLinksLHSandRHS())-> collect(r|thisModule.Links2RecTerm(r,obj.id)))->
					append(sfeat)
					)	
}


lazy rule ObjectArgmsLhsApplyOngoing{
	from
		p : Behavior!Pattern,
		obj : Behavior!Object,
		sfeat : Maude!Variable
	to
		sfi : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <-	--thisModule.LinksWithoutDuplicates(obj.outLinks) -> collect(l|thisModule.Links2RecTerm(l))->
					--thisModule.RefWithoutDuplicates(obj.outLinks) -> collect(r|thisModule.Links2RecTerm(r,obj.id))->
					thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())-> collect(r|thisModule.Links2RecTerm(r,obj.id))->
					union(obj.sfs -> collect(s|thisModule.Slots2RecTerm(s)))->
					-- Esto es para a�adir los LINK y SLOTS presentes en RHS y que hay que a�adir/inicializar en LHS
					union(p.getRHSSlotsNoIni(obj)->collect(r|thisModule.Slots2RecTerm(r)))->					
					--union(thisModule.LinksWithoutDuplicates(p.getRHSLinksNoIni(obj))->collect(n|thisModule.Links2RecTerm(n)))->
					--union(thisModule.RefWithoutDuplicates(p.getRHSLinksNoIni(obj)) -> collect(r|thisModule.Links2RecTerm(r,obj.id)))->
					union(thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(p.getRHSLinksNoIni(obj)),obj.getOppositeLinksRHSThatNotAreInLHS())-> collect(r|thisModule.Links2RecTerm(r,obj.id)))->
					
					append(sfeat)
					)

}






lazy rule ObjectArgmsRhsApplyOngoing{
	from
		p : Behavior!Pattern, -- es un RHS
		obj : Behavior!Object,
		sfeat : Maude!Variable
	to
		sfi : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <-	--obj.outLinks -> collect(l|thisModule.Links2RecTermRHS(l))->
					--Creo que en vez de la de arriba seria:
					--obj.outLinks -> collect(l|thisModule.LinksAddRef(l))->
					--thisModule.RefWithoutDuplicates(obj.outLinks)->collect(r|thisModule.LinksUpdate(r,obj,false))->
					thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())-> collect(r|thisModule.LinksUpdate(r,obj,false))->
					
					union(obj.sfs -> collect(s|thisModule.Slots2RecTermRHS(s)))->
					-- Esto es para a�adir los LINK y SLOTS presentes en RHS y que hay que a�adir/inicializar en LHS
					union(p.getLHSSlotsNoIni(obj)->
						collect(r|thisModule.Slots2RecTerm(r)))->		
					
--					union(thisModule.LinksWithoutDuplicates(p.getLHSLinksNoIni(obj))->
--						collect(n|thisModule.Links2RecTerm(n)))->						
--					union(thisModule.RefWithoutDuplicates(p.getLHSLinksNoIni(obj))->
--						collect(r|thisModule.LinksUpdate(r,obj,false)))->
						
					--union(thisModule.RefWithoutDuplicates(p.getLHSLinksNoIni(obj))->collect(r|thisModule.LinksUpdateLHS(r,obj.SameObjInLHS())))->
					union(thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(p.getLHSLinksNoIni(obj)),obj.OppositeLHSLinksNiIni())-> collect(r|thisModule.LinksUpdateLHS(r,obj.SameObjInLHS())))->					
					
					append(sfeat)
					)
	
}





lazy rule NewObjectArgmsRHS{
	from
		obj : Behavior!Object
	to
		sfi : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <-	--obj.outLinks -> collect(l|thisModule.LinksAddRefRHS(l)) ->
					--thisModule.RefWithoutDuplicates(obj.outLinks)->collect(r|thisModule.LinksUpdate(r,obj,true))->
					thisModule.AllObjectReferences(thisModule.RefWithoutDuplicates(obj.outLinks),obj.OppositeLinks())-> collect(r|thisModule.LinksUpdate(r,obj,true))->
						union(obj.sfs -> collect(s|thisModule.Slots2RecTermRHS(s)))						
						)
}

--------------------------------------------------------------------------------------------------------------------------





------------------------------------------------------------------------------------------------------------------------------
---------------------------------------Reglas para los LINKS------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------


-- Devuelve los LINKs de una rule que est�n presentes en LHS pero no en RHS
--helper context Behavior!Rule def: deletedLinks() : Sequence(Behavior!Link)=
--	self.lhs.linksRule() ->	select(o| not self.rhs.linksRule()->exists(l|l.ref=o.ref and l.src.id=o.src.id and l.target.id=o.target.id));
--
--
--
--helper context Behavior!Link def: DeletedLinks() : Sequence(Behavior!Link)=
--	self.src.outLinks->select(i|i.ref=self.ref)->select(o| not self.pattern."rule".rhs.linksRule()->exists(l|l.ref=o.ref and l.src.id=o.src.id and l.target.id=o.target.id));
--
--helper context Behavior!Link def : LinksToDelete() : Maude!Term =
--	if l.DeletedLinks()->isEmpty() then thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
--	else
--		if l.DeletedLinks()->size()=1 then thisModule.LinkSimple(l.DeletedLinks()->first())
--		else thisModule.LinkList(l.DeletedLinks())
--		endif
--	endif;


helper context Behavior!Object def: SameObjInRHS() : Behavior!Object=
	self.pattern."rule".rhs.els -> select(o|o.oclIsTypeOf(Behavior!Object)) -> any(j|j.id=self.id);



helper context Behavior!Object def: SameObjInLHS() : Behavior!Object=
	self.pattern."rule".lhs.els -> select(o|o.oclIsTypeOf(Behavior!Object)) -> any(j|j.id=self.id);

helper context Behavior!Object def: DeletedLinks(r:Behavior!EReference,lnks : Sequence(Behavior!Link)) : Sequence(Behavior!Link)=
	r.LinksWithConcreteRef(self.SameObjInLHS().outLinks)->   --Coleccionamos los Links del mismo objeto, en la parte izquierda que son del mismo tipo de referencia
		select(o|not lnks->exists(l|l.ref=o.ref and l.src.id=o.src.id and l.target.id=o.target.id)); --nos quedamos con los links coleccionados antes que no estan en la lista que le pasamos(links de ese objeto en la parte derecha del mismo tipo de referencia)
--	r.LinksWithConcreteRef(self.SameObjInLHS().outLinks)->   --Coleccionamos los Links del mismo objeto, en la parte izquierda que son del mismo tipo de referencia
--		select(o|not lnks->exists(l|l.ref=o.ref and l.src.id=o.src.id and l.target.id=o.target.id)); --nos quedamos con los links coleccionados antes que no estan en la lista que le pasamos(links de ese objeto en la parte derecha del mismo tipo de referencia)
--		
--	r.LinksWithConcreteRef(self.SameObjInLHS().outLinks),self.SameObjInLHS().GetOppositeLinks(r)


helper context Behavior!Object def: DeletedOppositeLinks(r:Behavior!EReference,opLnks : Sequence(Behavior!Link)) : Sequence(Behavior!Link)=	
	self.SameObjInLHS().GetOppositeLinks(r)->
		select(o|not opLnks->exists(l|l.ref.eOpposite=o.ref.eOpposite and l.src.id=o.src.id and l.target.id=o.target.id));
		
		
		
--helper context Behavior!Object def : LinksToDelete(r:Behavior!EReference, lnks : Sequence(Behavior!Link)) : Maude!Term =
--	if self.DeletedLinks(r,lnks)->isEmpty() then thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
--	else
--		if self.DeletedLinks(r,lnks)->size()=1 then thisModule.LinkSimple(self.DeletedLinks(r,lnks)->first())
--		else thisModule.LinkList(self.DeletedLinks(r,lnks))
--		endif
--	endif;	


helper context Behavior!Object def : LinksToDelete(r:Behavior!EReference, lnks : Sequence(Behavior!Link), opLnks : Sequence(Behavior!Link)) : Maude!Term =
	if self.DeletedLinks(r,lnks)->isEmpty() and self.DeletedOppositeLinks(r,opLnks)->isEmpty() then 
		thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
	else
		if self.DeletedLinks(r,lnks)->size()=1 and self.DeletedOppositeLinks(r,opLnks)->isEmpty() then 
			thisModule.LinkSimple(self.DeletedLinks(r,lnks)->first())
		else
			if self.DeletedLinks(r,lnks)->isEmpty() and self.DeletedOppositeLinks(r,opLnks)->size()=1 then
				thisModule.OppositeLinkSimple(self.DeletedOppositeLinks(r,opLnks)->first())
			else
				thisModule.LinkList(self.DeletedLinks(r,lnks),self.DeletedOppositeLinks(r,opLnks))
			endif
		endif
	endif;
		
		


helper def : LinksToAdd( lnks : Sequence(Behavior!Link), opLnks : Sequence(Behavior!Link)) : Maude!Term =
	if lnks->isEmpty() and opLnks->isEmpty() then thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
	else
		if lnks->isEmpty() and opLnks->size()=1 then thisModule.OppositeLinkSimple(opLnks->first())			
		else
			if lnks->size()=1 and opLnks->isEmpty() then thisModule.LinkSimple(lnks->first())
			else thisModule.LinkList(lnks,opLnks)
			endif
		endif
	endif;
	
	
	
	
-------------------------Crea los LINKS de RHS------------------------------------

lazy rule LinksUpdate{
	from
		r : Behavior!EReference,
		--lnks : Sequence(Behavior!Link),
		obj : Behavior!Object,
		isNewObject : Boolean
	to
		ref : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{left,right}
			),
		left : Maude!Constant(
			op <- r.maudeName().processSpecOpChars(), --l.ref.maudeName().processSpecOpChars(),
			type <- thisModule.oclTypeSort
		),
		right : Maude!RecTerm(
			op <- thisModule.updateOp,					
			type <- thisModule.oclTypeSort,
			args <- ---Sequence{oidArg,thisModule.CreateVariable(l.ref.name.toUpper().processSpecOpChars()+'@'+l.src.id+'@ATT',thisModule.oclTypeSort),,}			
					if isNewObject then 
						Sequence{refArg,
								thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort),
								thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),--obj.LinksToDelete(r.LinksWithConcreteRef(obj.outLinks)),
								thisModule.LinksToAdd(r.LinksWithConcreteRef(obj.outLinks),obj.GetOppositeLinks(r))
								}
					else Sequence{refArg,
								thisModule.CreateVariable(r.name.toUpper().processSpecOpChars()+'@'+obj.id+'@ATT',thisModule.oclTypeSort),
								obj.LinksToDelete(r,r.LinksWithConcreteRef(obj.outLinks),obj.GetOppositeLinks(r)), --obj.LinksToDelete(r,r.LinksWithConcreteRef(obj.outLinks)),
								thisModule.LinksToAdd(r.LinksWithConcreteRef(obj.outLinks),obj.GetOppositeLinks(r))
								}
					endif														 
		),	 
		refArg : Maude!Constant(
			op <- r.maudeName().processSpecOpChars(), --l.ref.maudeName().processSpecOpChars(),
			type <- thisModule.sortRefSimple
		)
}


helper context Behavior!Object def : LinksToDeleteLHS(lnks : Sequence(Behavior!Link), opLnks : Sequence(Behavior!Link)) : Maude!Term =
--	if lnks->isEmpty() then thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
--	else
--		if lnks->size()=1 then thisModule.LinkSimple(lnks->first())
--		else thisModule.LinkList(lnks,oclUndefined)
--		endif
--	endif;	
	if lnks->isEmpty() and opLnks->isEmpty() then thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
	else
		if lnks->isEmpty() and opLnks->size()=1 then thisModule.OppositeLinkSimple(opLnks->first())			
		else
			if lnks->size()=1 and opLnks->isEmpty() then thisModule.LinkSimple(lnks->first())
			else thisModule.LinkList(lnks,opLnks)
			endif
		endif
	endif;


lazy rule LinksUpdateLHS{
	from
		r : Behavior!EReference,		
		obj : Behavior!Object--,
		--isNewObject : Boolean
	to
		ref : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{left,right}
			),
		left : Maude!Constant(
			op <- r.maudeName().processSpecOpChars(),
			type <- thisModule.oclTypeSort
			),
		right : Maude!RecTerm(
			op <- thisModule.updateOp,					
			type <- thisModule.oclTypeSort,
			args <- Sequence{refArg,
							thisModule.CreateVariable(r.name.toUpper().processSpecOpChars()+'@'+obj.id+'@ATT',thisModule.oclTypeSort),
							obj.LinksToDeleteLHS(r.LinksWithConcreteRef(obj.outLinks),obj.GetOppositeLinks(r)),
							thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort)
							}																		 
			),	 
		refArg : Maude!Constant(
			op <- r.maudeName().processSpecOpChars(), --l.ref.maudeName().processSpecOpChars(),
			type <- thisModule.sortRefSimple
		)
}





----Variable con el nombre de un LINK--------------
lazy rule LinkSimple{
	from
		lnk : Behavior!Link
	to
		oper : Maude!RecTerm(
			op <- thisModule.linkOperator, -- link
			type <- thisModule.linkSort,
			args <- if (lnk.pos.oclIsUndefined()) or (lnk.pos='') then Sequence{target,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}					
					else Sequence{target,thisModule.allOclExpressions->any(i|lnk.pos=i.name).initExpression.oclExpConverter()}					
					endif
			),
		target : Maude!Variable(
			name <- lnk.target.id,
			type <- thisModule.oclTypeSort
			)		
}

----Variable con el nombre de un LINK--------------
lazy rule OppositeLinkSimple{
	from
		lnk : Behavior!Link
	to
		oper : Maude!RecTerm(
			op <- thisModule.linkOperator, -- link
			type <- thisModule.linkSort,
			args <- --Sequence{src,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}
					if (lnk.pos.oclIsUndefined()) or (lnk.pos='') then Sequence{src,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}					
					else Sequence{src,thisModule.allOclExpressions->any(i|lnk.pos=i.name).initExpression.oclExpConverter()}					
					endif
			),
		src : Maude!Variable(
			name <- lnk.src.id,
			type <- thisModule.oclTypeSort
			)		
}




----Crea una listOrd(Lista Ordenada) para contener LINKS-------------------
--lazy rule LinkList{
--	from
--		lnk : Sequence(Behavior!Link)
--	to
--		recT : Maude!RecTerm(
--			op <- thisModule.myLinkListOperator, --'__'     --thisModule.listOrdOperator, -- '_;_'
--			type <- thisModule.myLinkListSort, --thisModule.listOrdSort, -- thisModule.myLinkListSort,
--			args <- Sequence{lnk->collect(i|thisModule.LinkSimple(i))}
--			)
--}

----Crea una listOrd(Lista Ordenada) para contener LINKS-------------------
lazy rule LinkList{
	from
		lnk : Sequence(Behavior!Link),
		opLnks : Sequence(Behavior!Link)
	to
		recT : Maude!RecTerm(
			op <- thisModule.myLinkListOperator, --'__'     --thisModule.listOrdOperator, -- '_;_'
			type <- thisModule.myLinkListSort, --thisModule.listOrdSort, -- thisModule.myLinkListSort,
			args <- Sequence{lnk->collect(i|thisModule.LinkSimple(i))}->
						union(opLnks->collect(j|thisModule.OppositeLinkSimple(j)))
			)
}



----Variable con el nombre de un LINK--------------
lazy rule LinkSimpleDPO{
	from
		lnk : Behavior!Link
	to
		oper : Maude!RecTerm(
			op <- thisModule.linkOperator, -- link
			type <- thisModule.linkSort,
			args <- if (lnk.pos.oclIsUndefined()) or (lnk.pos='') then Sequence{source,target,reference,thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort)}					
					else Sequence{source,target,reference,thisModule.allOclExpressions->any(i|lnk.pos=i.name).initExpression.oclExpConverter()}					
					endif
			),
		source : Maude!Variable(
			name <- lnk.src.id,
			type <- thisModule.oclTypeSort
			),
		target : Maude!Variable(
			name <- lnk.target.id,
			type <- thisModule.oclTypeSort
			),
		reference : Maude!Constant(
			op <- lnk.ref.maudeName().processSpecOpChars(),
			type <- thisModule.sortRefSimple
			)		
}

----Crea una listOrd(Lista Ordenada) para contener LINKS-------------------
lazy rule LinkListDPO{
	from
		lnk : Sequence(Behavior!Link)
	to
		recT : Maude!RecTerm(
			op <- thisModule.myLinkListOperator, --'__'     --thisModule.listOrdOperator, -- '_;_'
			type <- thisModule.myLinkListSort, --thisModule.listOrdSort, -- thisModule.myLinkListSort,
			args <- Sequence{lnk->collect(i|thisModule.LinkSimple(i))}
			)
}




-- Se manejan mediante la operacion addRef
--lazy rule LinksAddRef{  
--	from
--		l : Behavior!Link
--	to
--		ref : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{left,right}
--			),
--		left : Maude!Constant(
--			op <- l.ref.maudeName().processSpecOpChars(),
--			type <- thisModule.oclTypeSort
--		),
--		right : Maude!RecTerm(
--			op <- thisModule.addRefOperator,					
--			type <- thisModule.oclTypeSort,
--			args <- if (l.pos.oclIsUndefined()) or (l.pos='') then Sequence{oidArg,refArg,oclTypeArg} 					
--					else Sequence{oidArg,refArg,oclTypeArg,thisModule.allOclExpressions->any(i|l.pos=i.name).initExpression.oclExpConverter()}
--					endif 
--		),
--		oidArg : Maude!Variable(
--			name <- l.target.id, --l.ref.name,
--			type <- thisModule.oclTypeSort --thisModule.sortOid
--		),
--		refArg : Maude!Constant(
--			op <- l.ref.maudeName().processSpecOpChars(),
--			type <- thisModule.sortRefSimple--l.ref.refType()
--		),
--		oclTypeArg :  Maude!Variable(
--			name <- l.ref.name.toUpper().processSpecOpChars()+'@'+l.src.id+'@ATT', 
--			type <- thisModule.oclTypeSort --thisModule.collectionSort  
--		) 
--}
-------------------------------------------------------------------------------------------------------------


-------------------------Crea los LINKS de los objetos que se CREAN en RHS------------------------------------

--lazy rule LinksAddRefRHS{
--	from
--		l : Behavior!Link
--	to
--		ref : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{left,right}
--			),
--		left : Maude!Constant(
--			op <- l.ref.maudeName().processSpecOpChars(),
--			type <- thisModule.oclTypeSort
--		),
--		right : Maude!RecTerm(
--			op <- thisModule.addRefOperator,					
--			type <- thisModule.oclTypeSort,
--			args <- if (l.pos.oclIsUndefined()) or (l.pos='') then Sequence{oidArg,refArg,oclTypeArg} 
--					--else Sequence{oidArg,refArg,oclTypeArg,thisModule.ConstPosition(l.pos)}
--					else Sequence{oidArg,refArg,oclTypeArg,thisModule.allOclExpressions->any(i|l.pos=i.name).initExpression.oclExpConverter()}
--					endif 
--		),
--		oidArg : Maude!Variable(
--			name <- l.target.id, --l.ref.name,
--			type <- thisModule.oclTypeSort --thisModule.sortOid
--		),
--		refArg : Maude!Constant(
--			op <- l.ref.maudeName().processSpecOpChars(),
--			type <- thisModule.sortRefSimple--l.ref.refType()
--		),
--		oclTypeArg :  Maude!Constant(
--			op <- thisModule.nullOperator,
--			type <- thisModule.oclTypeSort --thisModule.collectionSort  
--		) 
--}
-------------------------------------------------------------------------------------------------------------



-----------------Rule para transformar los Link de LHS---------------------
-- Links sin computar. *Esta hecho seg�n primera versi�n,se toma como valor el id del destino al que apunta< la ref*
--lazy rule Links2RecTerm{
--	from
--		link : Behavior!Link
--	to
--		ref : Maude!RecTerm(
--			op <- thisModule.sfsOperator, -- '_:_'
--			type <- thisModule.sortRefInst,
--			args <- Sequence{constSF,varSF}
--			),
--		constSF : Maude!Constant(
--			op <-  link.ref.maudeName().processSpecOpChars(),
--			type <- thisModule.sortRefSimple		
--			),
--		varSF : Maude!Variable(
--			name <- link.ref.name.toUpper().processSpecOpChars()+'@'+link.src.id+'@ATT', --link.target.id, --.toUpper() + '@' + link.src.id + '@ATT' ,
--			type <- thisModule.oclTypeSort --thisModule.collectionSort  
--			)
--}


lazy rule Links2RecTerm{
	from		
		linkRef : Behavior!EReference,
		objId : String
	to
		ref : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{constSF,varSF}
			),
		constSF : Maude!Constant(
			op <-  linkRef.maudeName().processSpecOpChars(),
			type <- thisModule.sortRefSimple		
			),
		varSF : Maude!Variable(
			name <- linkRef.name.toUpper().processSpecOpChars()+'@'+objId+'@ATT', --link.target.id, --.toUpper() + '@' + link.src.id + '@ATT' ,
			type <- thisModule.oclTypeSort --thisModule.collectionSort  
			)
}






------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------------
--------------------------------Reglas para los SLOTS-------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------


-------------- Regla para transformar los SLOTS ---------------------------------------------------------------------
--Los valores de un Slot y una Variable son computados como Variables. El tipo depende de su Structural Feature Type
--pero lo simplificamos todos al tipo OCL-TYPE
lazy rule Slots2RecTerm{
	from
		slot : Behavior!Slot
	to
		stft : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- slot.sf.TypeOfInstance(),
			args <- Sequence{constIzq,constDer}
			),
		constIzq : Maude!Constant(
			op <-  slot.sf.maudeName().processSpecOpChars(),--slot.sf.name,
			type <- slot.sf.slotType()			
			),
		constDer : Maude!Variable(
			name <- slot.sf.name.toUpper().processSpecOpChars() + '@' + slot.object.id + '@ATT',
			type <- thisModule.oclTypeSort--slot.sf.structFeatType() 
		)
}

------------------------ Crea los SLOTS(Atributos) de RHS ----------------------------------------------------------------
--Se incluir�n los Atributos computados

--Falta arreglar lo de las OCL expression, esta comentado a falta de arreglar lo de las nomenclaturas con @
lazy rule Slots2RecTermRHS{
	from
		slot : Behavior!Slot
	to
		stft : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- slot.sf.TypeOfInstance(),
			args <- Sequence{constIzq,constDer}
			),
		constIzq : Maude!Constant(
			op <-  slot.sf.maudeName().processSpecOpChars(),
			type <- slot.sf.slotType()			
			),
		constDer : Maude!RecTerm(
			op <- thisModule.evalOperator, --'eval'
			type <- thisModule.oclExpSort,
			args <- Sequence{thisModule.allOclExpressions->any(i|slot.oclValue=i.name).initExpression.oclExpConverter(),arg2,arg3}
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- ctx
			),
		ctx : Maude!RecTerm(
			op <- thisModule.ctxOperator,
			type <- thisModule.varPairSort,
			args <- Sequence{slf,id}
			),
		slf : Maude!Constant(
			op <- thisModule.selfOp,
			type <- thisModule.vidSort
			),
		id : Maude!Variable(
			name <- slot.object.id,
			type <- thisModule.oclTypeSort --thisModule.oclTypeSort
			),		
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}

------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------






--------------------------------------Crea un Sort por cada clase nueva que aparece
unique lazy rule Class2Sort{
	from
		eobj : Behavior!EClass--EObject
	to
		srt : Maude!Sort(
			"module" <- thisModule.sModuleEMot,
			name <- eobj.maudeName()
			)
}




-----------------------------------------------------------
-------------------------CONDITIONS------------------------
-----------------------------------------------------------

------ Condiciones donde se inicializan los ObjectRole-----------
-- ORi@ := newId(VALUE@ids@ + numero)
lazy rule CondOR{
	from
		i : Integer,
		j : Integer
	to
		matchOR : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'OR'+i.toString()+'@',
			type <- thisModule.sortOid
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.newIdOperator,--'newId(_)',
			type <- thisModule.sortOid,
			args <- sum
			),
		sum : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{orArg,cteArg}
			),
		orArg : Maude!Variable(
			name <- 'VALUE@ids@',--'VALUE@CNT@', 
			type <- thisModule.intSort 
			),
		cteArg : Maude!Constant(
			op <- j.toString(),
			type <- thisModule.intSort
			)
}
-----------------------------------------------------------------

-- id := newId(VALUE@ids@ + j)
lazy rule CondInitializeVar{
	from
		id : String,
		j : Integer
	to
		matchOR : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- id,--'OR'+i.toString()+'@',
			type <- thisModule.oclTypeSort--thisModule.sortOid
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.newIdOperator,--'newId(_)',
			type <- thisModule.sortOid,
			args <- sum
			),
		sum : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{orArg,cteArg}
			),
		orArg : Maude!Variable(
			name <- 'VALUE@ids@',--'VALUE@CNT@', 
			type <- thisModule.intSort 
			),
		cteArg : Maude!Constant(
			op <- j.toString(),
			type <- thisModule.intSort
			)
}
-----------------------------------------------------------------


------ Condiciones donde se inicializan los ObjectRole-----------
-- VARi@ := newId(VALUE@ids@ + numero)
lazy rule CondVAR{
	from
		i : Integer,
		j : Integer
	to
		matchOR : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'VAR'+i.toString()+'@',
			type <- thisModule.sortOid
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.newIdOperator,--'newId(_)',
			type <- thisModule.sortOid,
			args <- sum
			),
		sum : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{var,const}
			),
		var : Maude!Variable(
			name <- 'VALUE@ids@',--'VALUE@CNT@',--+' + '+j.toString(),
			type <- thisModule.intSort 
			),
		const : Maude!Constant(
			op <- j.toString(),
			type <- thisModule.intSort
			)
}
-----------------------------------------------------------------


--------- como se presenta en lhs de la regla Maude--------------------------
lazy rule LhsCondInstantaneous{
	from
		rl :Behavior!Rule
	to
		matchCond : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, --'__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermApplyOngoingLHS(i,rl.lhs)
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}					
				)
	do{
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;			
	}
			
}




------ Condition: variable MODEL@ que representa el modelo--------------------
--------- como se presenta en lhs de la regla Maude--------------------------
lazy rule lhsCond{
	from
		rl :Behavior!Rule
	to
		matchCond : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable(
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, --'__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,rl.lhs)
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateClock(rl.lhs),thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}			
			)
	do{
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});		
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;		
	}
}
----------------------------------------------------------------------------------

------ MODEL Condition of ApplyOngoing
lazy rule lhsCondApplyOngoing{
	from
		rl :Behavior!Rule
	to
		matchCond : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, --'__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermApplyOngoingLHS(i,rl.lhs)
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimerRealization(rl,false),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}
			)
	do{
		--for (p in rl.objectsLHSRule()){
		for (p in rl.objActExecLHSRule()){
			thisModule.counter <- thisModule.counter +1;
			lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});			
		}
		thisModule.counter <- 0;	
		
		for (p in rl.vbles){
			thisModule.counterVar <- thisModule.counterVar +1;
			--lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
			lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateFreezeVarApply(p,thisModule.counterVar)});
		}
		thisModule.counterVar <- 0;		
		
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--rhsTermArgs.args <- rhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--lhsTermArgsPost.args <- lhsTermArgsPost.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;			
		
	}
}
-------------------------------------------------------------------------



------------------------------------------------------------------------

lazy rule lhsCondRealization{
	from
		rl :Behavior!Rule
	to
		matchCond : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( --se utiliza una variable para el nombre del metamodelo para poder utilizar cualquiera
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator, --'__'
			type <- thisModule.sortSetObject,
			args <- 
					Sequence{
					rl.objActExecLHSRule()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTermRealization(i,rl.lhs)
													else thisModule.ActEx2RecTerm(i,i.ActExecExistsInRHS())
													endif),
					thisModule.CreateTimerRealization(rl,false),thisModule.CreateClock(rl.lhs),
					thisModule.CreateCounter(0),thisModule.CreateRandomCounter(false),thisModule.CreateOBJSET('')
					}
				)
	do{	
		--for (p in rl.objectsLHSRule()){
		for (p in rl.objActExecLHSRule()){
			thisModule.counter <- thisModule.counter +1;
			lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counter)});			
		}
		thisModule.counter <- 0;
		
		for (p in rl.vbles){
			thisModule.counterVar <- thisModule.counterVar +1;
			lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateVar(p,thisModule.counterVar)});
		}
		thisModule.counterVar <- 0;
		
--������������MODIFICADO EL 20/01/10!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--������������MODIFICADO EL 20/01/10!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		for (p in rl.lhs.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;				
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});				
			}
			thisModule.countORAE <- 0;
		}
--������������MODIFICADO EL 20/01/10!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--������������MODIFICADO EL 20/01/10!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	}
}


------Condition de inicializaci�n del Timer---------------
-- se inicializa con el Valor del Contador
lazy rule TimerCond{
	from
		blank :String
	to
		timerMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'ACTEXEC@', --'TIMER@',
			type <- thisModule.sortOid
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.newIdOperator,   --'newId'
			type <- thisModule.sortOid,
			args <- timerArg 
			),
		timerArg : Maude!Variable(
			name <- 'VALUE@ids@',--'VALUE@CNT@',
			type <- thisModule.intSort
		)
}
--------------------------------------------------------

----------Condicion: Operacion CURRENT EXECUTION -----------------
-- Se utiliza para evitar un numero indefinido de ejecuciones de la regla
lazy rule CurrentExecCondition{
	from
		rl : Behavior!Rule
	to
		timerCond : Maude!BooleanCond(
			lhs <- lhsTerm
			),
		lhsTerm : Maude!RecTerm(
			op <- thisModule.notOperator,--'not_',
			type <- thisModule.oclExpSort, --thisModule.boolSort,--thisModule.sortOid,
			args <- rtTimer--Sequence{objs,model}
			),
		rtTimer : Maude!RecTerm(
			op <- 'currentExec@'+rl.name.processSpecOpChars(),  -- +'(_`,_)',
			type <- thisModule.boolSort, --thisModule.oclExpSort,
			args <- Sequence{set,model}					
			),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
						else thisModule.ManyPatternElOid(rl)
						endif
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 	
--					if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
--						else thisModule.ManyPatternElOid(rl)
--						endif
--					endif
--			),
		model : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}

	----------REGLAS AUXILIARES---------
	--Crean una lista con variables que contienen los identifcadores de los elementos del patron de una regla
	lazy rule PatternElOid{
		from
			o : Behavior!PatternEl	
		to
			d : Maude!Variable(
				name <- o.id,
				type <- thisModule.oclTypeSort
				)
	}

	lazy rule ManyPatternElOid{
		from
			r : Behavior!Rule
		to
			participantsRT : Maude!RecTerm(
				op <- thisModule.mSetOperator, --thisModule.setOperator, -- '_`,_'
				type <- thisModule.mSetSort, --thisModule.listSort, 
				args <- r.objActExecLHSRule()->collect(e|thisModule.PatternElOid(e))
				)
	}
	-----FIN REGLAS AUXILIARES-------------	

	
---------- Condicion: DPO -----------------
	--- DPO FORMALIZATION
	---	1 argument: set of deleted elements (objects and action executions)
	--- 2 argument: link list of lhs links
	--- 3 argument: model
	---op dpo : Set MyLinkList @Model -> Bool . --- Of Oid
	---eq dpo(SET, MLL, MODEL) = 
	---		dpo(union(SET, getAllContainedOids(SET, MODEL)),
	---			 deleteEls(SET, deleteLinks(MLL, MODEL))) .
lazy rule DpoCondition{
	from
		rl : Behavior!Rule
	to
		rtDpo : Maude!RecTerm(
			op <- 'dpo', 
			type <- thisModule.boolSort, --thisModule.oclExpSort, 
			args <- --Sequence{deletedEl,myLinkList,model}					
			 		if rl.lhs.linksRule() -> isEmpty() then 
						Sequence{deletedEl,thisModule.CreateConstant(thisModule.nilOperator,thisModule.emptyListSort),model}
					else
						if rl.lhs.linksRule() -> size()=1 then Sequence{deletedEl,thisModule.LinkSimpleDPO(rl.lhs.linksRule()->first()),model}
						else Sequence{deletedEl,thisModule.LinkListDPO(rl.lhs.linksRule()),model}
						endif
					endif			
			),
		deletedEl : Maude!RecTerm( --se crea el contenedor Set_ para el conjunto de elementos borrados
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsDeleted
			args <- if rl.deletedObjects() -> isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.deletedObjects()->size()=1 then thisModule.PatternElDeleted(rl.deletedObjects()->first())
						else thisModule.PatternElDeletedMany(rl.deletedObjects())							
						endif
					endif
			),		
		model : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
	
	
	
	
-------------Condicion: Se crea una condicion booleana por cada NAC ------------------------------
-- Las operaciones NAC contendran como argumentos:
--1. un conjunto de los oid de los elementos de LHS
--2. un conjunto de objetos que representan a las variables
--3. una variable que contiene el modelo

lazy rule NacsCond{
	from
		n : Behavior!Pattern
	to	
	
		nacCond : Maude!BooleanCond(
			lhs <- rt
			),
		rt : Maude!RecTerm(
			op <- thisModule.notOperator, --'not'
			type <- thisModule.oclExpSort,
			args <- rtNac
			),
		rtNac : Maude!RecTerm(
			op <- n.name.toLower().processSpecOpChars()+'@'+n."rule".name.processSpecOpChars(),
			type <- thisModule.oclExpSort, --sortNac,
			args <- if (n."rule".vbles -> isEmpty()) then Sequence{set,thisModule.VariableEmpty(''),model}
					else
						if (n."rule".vbles -> size()=1) then Sequence{set,thisModule.CreateVar(n."rule".vbles -> first(),1),model}
						else
							Sequence{set,thisModule.CreateSetVar(n."rule"),model}
						endif
					endif
			),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if n."rule".objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
					else
						if n."rule".objActExecLHSRule()->size()=1 then thisModule.PatternElOid(n."rule".objActExecLHSRule()->first())
						else	thisModule.ManyPatternElOid(n."rule")
						endif
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 	
--					if n."rule".objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if n."rule".objActExecLHSRule()->size()=1 then thisModule.PatternElOid(n."rule".objActExecLHSRule()->first())
--						else	thisModule.ManyPatternElOid(n."rule")
--						endif
--					endif
--			),
		model : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
	---------------------REGLAS AUXILIARES--------------------------
	lazy rule VariableEmpty{
		from
			blank : String
		to
			var : Maude!Constant(
				op <- thisModule.varEmptyOp, --'none'
				type <- thisModule.oclTypeSort
				)
	}

	lazy rule CreateSetVar{
		from
			r : Behavior!AtomicRule
		to
			rt : Maude!RecTerm(
				op <- thisModule.objSetOperator,
				type <- thisModule.sortSetObject
				)
		do{
			for (p in r.vbles){
				thisModule.counterVbles <- thisModule.counterVbles +1;
				rt.args <- rt.args -> append(thisModule.CreateVar(p,thisModule.counterVbles));
			}
			thisModule.counterVbles <- 0;
		}
	}
	-------------------FIN REGLAS AUXILIARES------------------------------

----------------Condition de los Link------------------------
--Los Link son computados de la forma _in_ ---------------------
lazy rule LinkCondition{
	from
		lnk : Behavior!Link
	to
		cond : Maude!BooleanCond(
			lhs <- lhsTerm
			),
		lhsTerm : Maude!RecTerm(
			op <- thisModule.inOperator, 
			type <- thisModule.oclTypeSort, 
			args <- Sequence{e,l}
			),
		e : Maude!Variable(
			name <- lnk.target.id,
			type <- thisModule.oclTypeSort --thisModule.sortOid
			),
		l : Maude!Variable(
			name <- lnk.ref.name.toUpper().processSpecOpChars()+'@'+lnk.src.id+'@ATT', 
			type <- thisModule.oclTypeSort
			)
}
-----------------------------------------------------------------------

-------------------Condition de los Link con Posici�n-------------------------------
--Los Link son computados de la forma << 2 .=. Sequence[2 ; 3] -> at (1) >> .  ----
lazy rule LinkPosCondition{
	from
		lnk : Behavior!Link
	to
		cond : Maude!BooleanCond(
			lhs <- eval
			),
		eval : Maude!RecTerm(
			op <- thisModule.evalOperator,--'eval(_`,_`,_)',
			type <- thisModule.oclExpSort,
			args <- Sequence{exp,env,model}
			),
		exp : Maude!RecTerm(
			op <- thisModule.equalOperator, --'_.=._'
			type <- thisModule.oclExpSort,
			args <- Sequence{obj,at}
			),
		obj : Maude!Variable(
			name <- lnk.target.id,--lnk.src.id, --.toUpper(),
			type <- thisModule.oclTypeSort --thisModule.sortOid
			),
		at : Maude!RecTerm(
			op <- thisModule.atOperator, -- '_->`at`(_`)'
			type <- thisModule.oclExpSort,
			args <- Sequence{col,thisModule.allOclExpressions->any(i|lnk.pos=i.name).initExpression.oclExpConverter()}
			),
		col : Maude!Variable(
			name <- lnk.ref.name.toUpper().processSpecOpChars()+'@'+lnk.src.id+'@ATT', 
			type <- thisModule.oclTypeSort 
			),			
		env : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- empty
			),
		empty : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),	
		model : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
-----------------------------------------------------------------------



---Operaci�n y Ecuacion CURRENT EXECUTION---------------
--permite evitar la ejecuci�n de la regla cuando ya esta siendo ejecutada con los mismos participantes

lazy rule CurrentExecOp{
	from
		rl : Behavior!Rule
	to
		o : Maude!Operation(
			name <- 'currentExec@' + rl.name.processSpecOpChars(),
			arity <- Sequence{thisModule.setSort,thisModule.sortModel},
			coarity <- thisModule.boolSort,
			"module" <- thisModule.mainModule
		),	
		eqTrue : Maude!Equation(
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			"module" <- thisModule.mainModule
		),
		lhsTerm : Maude!RecTerm(
			op <- 'currentExec@' + rl.name.processSpecOpChars(),
			type <- thisModule.boolSort, 
			args <- Sequence{set,model}
		),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
						else thisModule.ManyPatternElOid(rl)
						endif
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 
--					if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
--						else thisModule.ManyPatternElOid(rl)
--						endif
--					endif
--		),	
		model : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mmInv,lhsTermArgsInv}
			),
		mmInv : Maude!Variable( 
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgsInv : Maude!RecTerm(
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <- Sequence{thisModule.CreateTimerCurrentExec(rl),thisModule.CreateOBJSET('')}
			),
		rhsTerm : Maude!Constant(
			op <- 'true',
			type <- thisModule.boolSort
			),
------------------------------------------------		
		eqFalse : Maude!Equation(
			lhs <- lhsEqFalse,
			rhs <- rhsEqFalse,
			"module" <- thisModule.mainModule,
			atts <- 'owise'
		),
		lhsEqFalse : Maude!RecTerm(
			op <- 'currentExec@' + rl.name.processSpecOpChars(),
			type <- thisModule.boolSort,
			args <- Sequence{oidsetVar,modelVar}
		),
		oidsetVar : Maude!Variable(
			name <- 'OIDSET@',
			type <- thisModule.setSort
		),		
		modelVar : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
		),
		rhsEqFalse : Maude!Constant(
			op <- 'false',
			type <- thisModule.boolSort
		)
	do{
		for (p in rl.objActExecLHSRule()){
			thisModule.counterOpTimer <- thisModule.counterOpTimer +1;
		 	lhsTermArgsInv.args <- lhsTermArgsInv.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counterOpTimer)});
		}
		thisModule.counterOpTimer <- 0;
	}
}
--------------------------------------------------------------------------------------------



----Por cada NAC asociado a una regla se crear� una operaci�n y una ecuaci�n-----------------		
--En la ecuacion los elementos del patr�n NAC son codificados como los elementos de LHS
lazy rule OperationNac{
	from
		n : Behavior!NAC
	to
		o : Maude!Operation(
			name <- n.name.toLower().processSpecOpChars() + '@' + n."rule".name.processSpecOpChars(),
			arity <- Sequence{thisModule.setSort,thisModule.sortSetObject,thisModule.sortModel},
			coarity <- thisModule.boolSort,
			"module" <- thisModule.mainModule
		),
		condEq : Maude!Equation(
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			"module" <- thisModule.mainModule,
			conds <- Sequence{wholeModel} ->
						union(n.patternObjects() -> collect(t|t.sfs) -> flatten() -> collect(t|thisModule.SlotsComputation(t))) ->
						union(n.els -> select(j|j.oclIsTypeOf(Behavior!Condition)) -> collect(r|thisModule.OCLConditionsComputation(r))) ->
						union(n.els -> select(e|e.oclIsTypeOf(Behavior!Link))->collect(o|o.LinkComputation()))
		),
		wholeModel : Maude!MatchingCond(
			lhs <- lhsWM,
			rhs <- thisModule.NacElements(n)
		),
		lhsWM : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
		),

		lhsTerm : Maude!RecTerm(
			op <- n.name.toLower().processSpecOpChars() + '@' + n."rule".name.processSpecOpChars(),
			type <- thisModule.boolSort, 			
			args <- if n."rule".vbles -> isEmpty() then Sequence{set,thisModule.VariableEmpty(''),thisModule.NacElements(n)}
					else
						if n."rule".vbles -> size()=1 then Sequence{set,thisModule.CreateVar(n."rule".vbles -> first(),1),thisModule.NacElements(n)}
						else Sequence{set,thisModule.CreateSetVar(n."rule"),thisModule.NacElements(n)}
						endif
					endif			
		),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if n."rule".objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
					else
						if n."rule".objActExecLHSRule()->size()=1 then thisModule.PatternElOid(n."rule".objActExecLHSRule()->first())
						else thisModule.ManyPatternElOid(n."rule")
						endif
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 
----					if n."rule".objectsLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
----					else
----						if n."rule".objectsLHSRule()->size()=1 then thisModule.ObjectsOid(n."rule".objectsLHSRule()->first())
----						else thisModule.ManyObjectsOid(n."rule")
----						endif
----					endif
--					if n."rule".objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if n."rule".objActExecLHSRule()->size()=1 then thisModule.PatternElOid(n."rule".objActExecLHSRule()->first())
--						else thisModule.ManyPatternElOid(n."rule")
--						endif
--					endif
--		),		
		rhsTerm : Maude!Constant(
			op <- 'true',
			type <- thisModule.boolSort
			),
			
			
			
		---Ecuaci�n con la condici�n de FALSE----------	
		eqFalse : Maude!Equation(
			lhs <- lhsEqFalse,
			rhs <- rhsEqFalse,
			"module" <- thisModule.mainModule,
			atts <- 'owise'
		),
		lhsEqFalse : Maude!RecTerm(
			op <- n.name.toLower().processSpecOpChars() + '@' + n."rule".name.processSpecOpChars(),
			type <- thisModule.boolSort,
			args <- Sequence{oidsetVar,currentTimerFalseVar,modelVar}
		),
		oidsetVar : Maude!Variable(
			name <- 'OIDSET@',
			type <- thisModule.setSort
		),		
		currentTimerFalseVar : Maude!Variable(
			name <- 'OBJSET@',
			type <- thisModule.sortSetObject
		),
		modelVar : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
		),
		rhsEqFalse : Maude!Constant(
			op <- 'false',
			type <- thisModule.boolSort
		)
--	do{
--		for (p in n.ActionExecEls()){
--			for (q in p.participants){
--				thisModule.countORAE <- thisModule.countORAE +1;												
--				crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
--			}
--			thisModule.countORAE <- 0;
--		}	
--	}
}
---------------------------------------------------------------------------------------------------------


--lazy rule EmptySet{
--	from
--		blank : String
--	to
--		set : Maude!RecTerm(
--			op <- thisModule.setOperator,
--			type <- thisModule.setSort,
--			args <- bracket
--			),
--		bracket : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- thisModule.ConstantEmpty('')
--			)
--}


---Regla auxiliar para crear los elementos (Objects y ActionExec) del NAC--------------------------------

lazy rule NacElements{
	from
		n : Behavior!Pattern
	to
		model : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mm,lhsTermArgs}
			),
		mm : Maude!Variable( 
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgs : Maude!RecTerm(
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <-  			
					Sequence{
					n.patternObjActExec()->collect(i|if i.oclIsTypeOf(Behavior!Object) then thisModule.Object2RecTerm(i,n)
													else thisModule.ActEx2RecTerm(i,true)
													endif),
					thisModule.CreateOBJSET('')
					}				
			)
	do{
		for (p in n.ActionExecEls()){
			for (q in p.participants){
				thisModule.countORAE <- thisModule.countORAE +1;
				lhsTermArgs.args <- lhsTermArgs.args -> union(Sequence{thisModule.CreateObjRoleActionExec(q,thisModule.countORAE)});								
				--crlpre.conds <- crlpre.conds -> prepend(thisModule.CondInitializeVar('OR'+thisModule.counter.toString()+'@'+p.id,thisModule.counter));
			}
			thisModule.countORAE <- 0;
		}	
		thisModule.countORAE <- 0;
	}
}
---------------------------------------------------------------------------------------------------------------------------------


lazy rule CreateActionExecOR{
	from
		obRol : Behavior!ObjectRole,
		num : Integer
	to
		o : Maude!RecTerm(
			op <- thisModule.objectOperator, -- '<_:_|_>'
			type <- thisModule.sortObject,--thisModule.Class2Sort(obj.class)--�crear funci�n para poner tipos class Structural feature?
			args <-	Sequence{id,objClass,argms}
			),
		id : Maude!Variable(
			name <- 'OR'+num.toString()+'@'+obRol.actionExec.id,
			type <- thisModule.sortOid
			),
		objClass : Maude!Constant(
			op <- 'ObjectRole@MGBehavior',
			type <- thisModule.sortObjRole
			),
		argms : Maude!RecTerm(
			op <- thisModule.featOperator, -- '_`,_'
			type <- thisModule.sortSetSfi,
			args <- if obRol.role.oclIsUndefined() then Sequence{actual,sfs}
					else Sequence{actual,thisModule.RoleSfs(obRol.role),sfs}
					endif
			),
			
		actual : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{constObj,varObj}--,thisModule.VariableStructFeat(obj,link)}--Sequence{thisModule.ConstantStructFeat(link.ref)}--, thisModule.VariableStructFeat(link.target)}
			),
		constObj : Maude!Constant(
			op <-  'actualObject@ObjectRole@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		varObj : Maude!Variable(
			name <- obRol.actualObject.id,
			type <- thisModule.oclTypeSort
			),

		sfs : Maude!Variable(
			name <- 'OR'+num.toString()+'@SFS', --'OR'+num.toString()+'@'+obRol.actionExec.id+'@SFS',
			type <- thisModule.sortStructFeat
			)		
}

lazy rule RoleSfs{
	from
		o : Behavior!Object
	to
			
		objR : Maude!RecTerm(
			op <- thisModule.sfsOperator, -- '_:_'
			type <- thisModule.sortRefInst,
			args <- Sequence{constObjR,varObjR}--,thisModule.VariableStructFeat(obj,link)}--Sequence{thisModule.ConstantStructFeat(link.ref)}--, thisModule.VariableStructFeat(link.target)}
			),
		constObjR : Maude!Constant(
			op <-  'role@ObjectRole@MGBehavior',
			type <- thisModule.sortRefSimple		
			),
		varObjR : Maude!Constant(
			op <- '"'+o.id+'"',
			type <- thisModule.stringSort
			)		
}



------------------- Condicion: COMPUTACI�N de los SLOTS----------------------------
-- Se inicializan los atributos a su valor en el modelo.
--The rule context variables must include the 'self' definition

--Falta arreglar lo de las OCL expression, esta comentado a falta de arreglar lo de las nomenclaturas con @
lazy rule SlotsComputation{
	from
		slot : Behavior!Slot
	to
		slotMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- slot.sf.name.toUpper().processSpecOpChars() + '@' + slot.object.id + '@ATT',
			type <- thisModule.oclTypeSort
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.evalOperator, --'eval'
			type <- thisModule.oclExpSort,
			args <- --Sequence{arg1,arg2b,arg3}
					Sequence{thisModule.allOclExpressions->any(i|slot.oclValue=i.name).initExpression.oclExpConverter(),arg2b,arg3}
			),
--		arg1 : Maude!Constant(
--			op <- slot.oclValue,					
--			type <- slot.sf.slotType()
--			),
		arg2b : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- ctx
			),
		ctx : Maude!RecTerm(
			op <- thisModule.ctxOperator,
			type <- thisModule.varPairSort,
			args <- Sequence{slf,id}
			),
		slf : Maude!Constant(
			op <- thisModule.selfOp,
			type <- thisModule.vidSort 
			),
		id : Maude!Variable(
			name <- slot.object.id,
			type <- thisModule.oclTypeSort --thisModule.oclTypeSort 
			),		
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
------------------------------------------------------------------------------------------

------------------- Condici�n: Computaci�n de las variables -------------------------
-- se inicializan las variables a su valor

lazy rule VarComputation{
	from
		var : Behavior!Variable
	to
		slotMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- var.name,
			type <- thisModule.oclTypeSort
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.evalOperator, --'eval',
			type <- thisModule.oclExpSort,
			args <- Sequence{thisModule.allOclExpressions->any(i|var.value=i.name).initExpression.oclExpConverter(),arg2,arg3}
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- empty
			),
		empty : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
--------------------------------------------------------------------------------------

-- se inicializan las variables a su valor

lazy rule FreezeVarComputation{
	from
		var : Behavior!Variable
	to
		slotMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- var.name,
			type <- thisModule.oclTypeSort
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.evalOperator, --'eval',
			type <- thisModule.oclExpSort,
			args <- --Sequence{thisModule.allOclExpressions->any(i|var.value=i.name).initExpression.oclExpConverter(),arg2,arg3}
					Sequence{arg1,arg2,arg3}
			),		 
		arg1 : Maude!Variable(
			name <- var.name.toString()+'@UNVALUED',
			type <- thisModule.oclExpSort
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- empty
			),
		empty : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
--------------------------------------------------------------------------------------




-- se inicializan las variables a su valor

lazy rule VarFreeze{
	from
		var : Behavior!Variable
	to
		slotMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- thisModule.allOclExpressions->any(i|var.value=i.name).initExpression.oclExpConverter() --rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- var.name,
			type <- thisModule.oclExpSort
			)
}
--------------------------------------------------------------------------------------




------------ Condicion: evalua las expresiones OCL-------------------------------------
-- Las expresiones ocl en el modelo de entrada son cadenas de texto. Estas cadenas de texto se transformaran a modelos
-- Los modelos de las expresiones OCL se transforman a metamodelo Maude mediante las reglas del final del  codigo

--Falta arreglar lo de las OCL expression, esta comentado a falta de arreglar lo de las nomenclaturas con @
lazy rule OCLConditionsComputation{
	from
		cond : Behavior!Condition
	to
		boolCond : Maude!BooleanCond(
			lhs <- eval
			),
		eval : Maude!RecTerm(
			op <- thisModule.evalOperator,--'eval(_`,_`,_)',
			type <- thisModule.oclExpSort,
			args <- Sequence{thisModule.allOclExpressions->any(i|cond.oclValue=i.name).initExpression.oclExpConverter(),arg2,arg3}
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- empty
			),
		empty : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),	
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
-------------------------------------------------------------------------------------------------


lazy rule MaxDurationOngoingComputation{
	from
		rl : Behavior!Rule,
		isApplyRule : Boolean
	to
		boolCond : Maude!BooleanCond(
			lhs <- comp
			),
		comp : Maude!RecTerm(
			op <- '_>_',
			type <- thisModule.oclExpSort,
			args <- Sequence{toRat,thisModule.CreateConstant('0',thisModule.intSort)} 
			),
		toRat : Maude!RecTerm(
			op <- thisModule.toRatOperator,
			type <- thisModule.ratSort,
			args <- eval
			),
		eval : Maude!RecTerm(
			op <- thisModule.evalOperator,--'eval(_`,_`,_)',
			type <- thisModule.oclExpSort,
			args <- if isApplyRule then Sequence{thisModule.CreateVariable('MAXDURATIONONGOING@',thisModule.oclExpSort),arg2,arg3}
					else Sequence{thisModule.allOclExpressions->any(i|rl.maxDuration=i.name).initExpression.oclExpConverter(),arg2,arg3} --
					endif
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- empty
			),
		empty : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),	
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
-------------------------------------------------------------------------------------------------

lazy rule ExecutionTimeComputation{
	from
		blank : String
	to
		execTimeMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'T',
			type <- thisModule.oclTypeSort
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.evalOperator,
			type <- thisModule.oclExpSort,
			args <- Sequence{arg1,arg2,arg3}
			),
		arg1 : Maude!Constant(
			op <- '0',
			type <- thisModule.intSort
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyArg
			),
		emptyArg : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		arg3 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}



-------------Condicion: Computaci�n de la MINDURACION de la REGLA------------------------
-- Se asigna a una variable MINDURATION@ el valor del atributo 'minDuration' de la regla

lazy rule MinDurationComputation{
	from
		rl : Behavior!AtomicRule
	to
		durationMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'MINDURATION@',
			type <- thisModule.timeSort  --thisModule.timeInfSort
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.toRatOperator, --'toRat'
			type <- thisModule.oclExpSort,
			args <- arg
			),
		arg : Maude!RecTerm(
			op <- thisModule.evalOperator,
			type <- thisModule.oclExpSort,
			args <- if rl.minDuration.oclIsUndefined() or rl.minDuration='' then 
						--Sequence{thisModule.CreateConstant('0',thisModule.intSort),arg2,modelArg}
						Sequence{thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort),arg2,modelArg}
					else
						if thisModule.allOclExpressions->exists(i|rl.minDuration=i.name) then						
							Sequence{thisModule.allOclExpressions->any(i|rl.minDuration=i.name).initExpression.oclExpConverter(),arg2,modelArg}					
						else Sequence{thisModule.CreateConstant(rl.minDuration,thisModule.intSort),arg2,modelArg}
						endif
					endif
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyArg
			),
		emptyArg : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		modelArg : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
-------------------------------------------------------------------
-------------Condicion: Computaci�n de la MAXDURACION de la REGLA------------------------
-- Se asigna a una variable MAXDURATION@ el valor del atributo 'maxDuration' de la regla

lazy rule MaxDurationComputation{
	from
		rl : Behavior!AtomicRule
	to
		durationMatch : Maude!MatchingCond(
			lhs <- lhsTerm,
			rhs <- rhsTerm
			),
		lhsTerm : Maude!Variable(
			name <- 'MAXDURATION@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),
		rhsTerm : Maude!RecTerm(
			op <- thisModule.toRatOperator, --'toRat'
			type <- thisModule.oclExpSort,
			args <- arg
			),
		arg : Maude!RecTerm(
			op <- thisModule.evalOperator,
			type <- thisModule.oclExpSort,
			args <- if rl.maxDuration.oclIsUndefined() or rl.maxDuration='' then 
						--Sequence{thisModule.CreateConstant('0',thisModule.intSort),arg2,modelArg}
						Sequence{thisModule.CreateConstant(thisModule.nullOperator,thisModule.oclTypeSort),arg2,modelArg}
					else
						if thisModule.allOclExpressions->exists(i|rl.maxDuration=i.name) then						
							Sequence{thisModule.allOclExpressions->any(i|rl.maxDuration=i.name).initExpression.oclExpConverter(),arg2,modelArg}					
						else Sequence{thisModule.CreateConstant(rl.maxDuration,thisModule.intSort),arg2,modelArg}
						endif
					endif
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyArg
			),
		emptyArg : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		modelArg : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}
-------------------------------------------------------------------



---Crea una condici�n cuando procede con el valor LOWERBOUND de la regla--------
lazy rule LowerBoundCondition{
	from
		rl : Behavior!Rule
	to
		cond : Maude!BooleanCond(
			lhs <- lowerTerm
			),
		lowerTerm : Maude!RecTerm(
			op <- thisModule.leOperator,
			type <- thisModule.boolSort,--thisModule.oclExpSort, ---�Esta bien este tipo?
			args <- Sequence{lowerRat,lowerTime} 
		),
		lowerRat : Maude!RecTerm(
			op <- thisModule.toRatOperator,
			type <- thisModule.ratSort,--thisModule.oclExpSort,
			args <- lowerCte
		),
		lowerCte : Maude!Constant(
			op <- rl.lowerBound.toString(),
			type <- thisModule.floatSort--thisModule.intSort
		),
		lowerTime : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
		)
}
--------------------------------------------------------------------------------


---Crea una condici�n cuando procede con el valor UPPERBOUND de la regla--------
lazy rule UpperBoundCondition{
	from
		rl : Behavior!Rule
	to
		cond : Maude!BooleanCond(
			lhs <- upperTerm
			),
		upperTerm : Maude!RecTerm(
			op <- thisModule.leOperator,
			type <- thisModule.boolSort,--thisModule.oclExpSort, ---�Esta bien este tipo?
			args <- Sequence{upperTime,upperRat} 
		),
		upperRat : Maude!RecTerm(
			op <- thisModule.toRatOperator,
			type <- thisModule.ratSort,--thisModule.oclExpSort,
			args <- upperCte
		),
		upperCte : Maude!Constant(
			op <- rl.upperBound.toString(),
			type <- thisModule.floatSort--thisModule.intSort
		),
		upperTime : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
		)
}
--------------------------------------------------------------------------------

--- Condici�n: operaci�n INPERIOD. Se incluye para reglas peri�dicas--------------
--lazy rule inPeriodCondition{
--	from
--		rl : Behavior!AtomicRule
--	to
--		cond : Maude!BooleanCond(
--			lhs <- inp
--			),
--		inp : Maude!RecTerm(
--			op <- thisModule.inPeriodOp, --'inPeriod(_`,_`,_)'
--			type <- thisModule.boolSort,
--			args <- Sequence{plus,timeClk,toRat}
--			),
--		plus : Maude!RecTerm(
--			op <- thisModule.plusOp, --'_plus_'
--			type <- thisModule.timeInfSort,
--			args <- Sequence{time,duration} 
--			),
--		time : Maude!Variable(
--			name <- 'TIME@CLK@',
--			type <- thisModule.timeInfSort
--			),			
--		duration : Maude!Variable(
--			name <- 'MINDURATION@',
--			type <- thisModule.timeInfSort
--			),	
--		timeClk : Maude!Variable(
--			name <- 'TIME@CLK@',
--			type <- thisModule.timeInfSort
--			),
--		toRat : Maude!RecTerm(
--			op <- thisModule.toRatOperator,
--			type <- thisModule.timeInfSort,
--			args <- period
--			),
--		period : Maude!Constant(
--			op <- rl.periodicity.toString(),
--			type <- thisModule.intSort
--			)	
--}
-----------------------------------------------------

---Condici�n MULTIPLE para reglas NO SOFT PERIODIC----------------
lazy rule multipleCondition{
	from
		rl : Behavior!AtomicRule
	to
		cond : Maude!BooleanCond(
			lhs <- inp
			),
		inp : Maude!RecTerm(
			op <- thisModule.multipleOp, --'multiple(_`,_)'
			type <- thisModule.boolSort,--thisModule.oclExpSort,
			args <- Sequence{timeClk,toRat}
			),		
		timeClk : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort 
			),
		toRat : Maude!RecTerm(
			op <- thisModule.toRatOperator,
			type <- thisModule.timeSort,
			args <- period
			),
		period : Maude!Constant(
			op <- rl.periodicity.toString(),
			type <- thisModule.floatSort
			)	
}
------------------------------------------------------------------



----Condicion para SOFT PERIODIC RULES--------------
lazy rule AlreadyCondition{
	from
		rl : Behavior!AtomicRule
	to
	
		alrCond : Maude!BooleanCond(
			lhs <- lhsTerm
			),
		lhsTerm : Maude!RecTerm(
			op <- thisModule.notOperator,--'not_',
			type <- thisModule.boolSort,
			args <- inp
			),	
		inp : Maude!RecTerm(
			op <- 'alreadyTrigInPeriod@'+rl.name.processSpecOpChars(),
			type <- thisModule.oclExpSort,
			args <- Sequence{set,modelArg,timeClk,toRat}
			),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
						else thisModule.ManyPatternElOid(rl)
						endif
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- 
--					if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
--						else thisModule.ManyPatternElOid(rl)
--						endif
--					endif
--		),
		modelArg : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			),
		timeClk : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort 
			),
		toRat : Maude!RecTerm(
			op <- thisModule.toRatOperator,
			type <- thisModule.timeSort,
			args <- period
			),
		period : Maude!Constant(
			op <- rl.periodicity.toString(),
			type <- thisModule.intSort
			)	
}
-------------------------------------------------------------------------------------------------------

---Condici�n: est� presente si la regla es SOFT PERIODIC (en lugar de la operacion MULTIPLE)-----------

	--- Already Executed In Period operation (for soft periodic rules)
	--- We forbid the execution of soft periodic rules whenever it has already been executed 
	---	within te period
	
lazy rule AlreadyOpEq{
	from
		rl : Behavior!Rule
	to
		o : Maude!Operation(
			name <- 'alreadyTrigInPeriod@'+rl.name.processSpecOpChars(),
			arity <- Sequence{thisModule.setSort,thisModule.sortModel,thisModule.timeSort,thisModule.timeSort2}, -- thisModule.timeInfSort,thisModule.timeInfSort2},
			coarity <- thisModule.boolSort,
			"module" <- thisModule.mainModule
		),
		e : Maude!Equation(
			"module" <- thisModule.mainModule,
			lhs <- lhsTerm,
			rhs <- rhsTerm,
			conds <- inp
		),
		rhsTerm : Maude!Constant(
			op <- 'true',
			type <- thisModule.boolSort
		),		
		lhsTerm : Maude!RecTerm(
			op <- 'alreadyTrigInPeriod@'+rl.name.processSpecOpChars(),
			type <- thisModule.boolSort, 
			args <- Sequence{set,model,timeClk,per}
		),
		set : Maude!RecTerm(
			op <- thisModule.setCollection,
			type <- thisModule.setSort,
			--args <- itemsSet
			args <- if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
					else
						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
						else thisModule.ManyPatternElOid(rl)
						endif
					endif
			),
--		itemsSet : Maude!RecTerm(
--			op <- thisModule.bracketsOp,
--			type <- thisModule.itemListSort,
--			args <- if rl.objActExecLHSRule()->isEmpty() then thisModule.ConstantEmpty('')
--					else
--						if rl.objActExecLHSRule()->size()=1 then thisModule.PatternElOid(rl.objActExecLHSRule()->first())
--						else thisModule.ManyPatternElOid(rl)
--						endif
--					endif
--		),
		
		model : Maude!RecTerm(
			op <- thisModule.modelOperator, -- '_{_}'
			type <- thisModule.sortModel,
			args <- Sequence{mmInv,lhsTermArgsInv}
			),
		mmInv : Maude!Variable( 
			name <- thisModule.oidMetamodel,
			type <- thisModule.sortMetamodel
			),
		lhsTermArgsInv : Maude!RecTerm(
			op <- thisModule.objSetOperator,
			type <- thisModule.sortSetObject,
			args <- Sequence{thisModule.CreateTimerAlready(rl),thisModule.CreateOBJSET('')}
			),
		timeClk : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),
		per : Maude!Variable(
			name <- 'PERIOD@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),
--------Condicion-----------------			
		inp : Maude!RecTerm(
			op <- thisModule.inPeriodOp, --'inPeriod(_`,_`,_)'
			type <- thisModule.boolSort,
			args <- Sequence{start,timeC,period}
			),
		start : Maude!Variable(
			name <- 'STARTINGTIME@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),		
		timeC : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
			),
		period : Maude!Variable(
			name <- 'PERIOD@', 
			type <- thisModule.timeSort --thisModule.timeInfSort
			),
-----------Equation false--------------------
		eqFalse : Maude!Equation(
			lhs <- lhsEqFalse,
			rhs <- rhsEqFalse,
			"module" <- thisModule.mainModule,
			atts <- 'owise'
		),
		lhsEqFalse : Maude!RecTerm(
			op <- 'alreadyTrigInPeriod@' + rl.name.processSpecOpChars(),
			type <- thisModule.boolSort,
			args <- Sequence{oidsetVar,modelVar,ti,pe}
		),
		oidsetVar : Maude!Variable(
			name <- 'OIDSET@',
			type <- thisModule.setSort
		),
		modelVar : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
		),
		ti : Maude!Variable(
			name <- 'TIME@CLK@',
			type <- thisModule.timeSort --thisModule.timeInfSort
		),
		pe : Maude!Variable(
			name <- 'PERIOD@', 
			type <- thisModule.timeSort --thisModule.timeInfSort
		),
		rhsEqFalse : Maude!Constant(
			op <- 'false',
			type <- thisModule.boolSort
		)
	do{
		--for (p in rl.objectsLHSRule()){
		for (p in rl.objActExecLHSRule()){
			thisModule.counterOpTimer <- thisModule.counterOpTimer +1;
		 	lhsTermArgsInv.args <- lhsTermArgsInv.args -> union(Sequence{thisModule.CreateObjRole(p,thisModule.counterOpTimer)});
		}
		thisModule.counterOpTimer <- 0;
	}
}
-----------------------------------------------------------------------------------------------------------------------------------






------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
------------------------------REGLAS DE TRANSFORMACION DE OCL A MODCL---------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------

-- Estas reglas van a transformar el modelo de las reglas OCL definido conforme a un metamodelo de OCL a un modelo
-- de OCL definido conforme a Maude. De ah� se generar� el c�digo Maude en forma de texto mediante transformaciones TCS


----------------------------------------------------------------------------------------------------------------------
--DIFERENCIAS ATL - OCL:
--	�Expresi�n Let: en ATL hay que poner el tipo de la variable, en OCL no. Como en realidad el parser es para ATL, hay que poner el tipo
--		Para el Let: En la Expresion OCL que se introduce al Parser hay que definir en la variable el tipo de la variable e inicializarla

--	�En una expresion Let: en la variable que se inicializa, si no es de un tipo primitivo hay que poner el tipo de la forma Metamodelo!Clase 

--	�En OCL existe el operador _.._ que tambi�n est� definido en mOdCL, en ATL no existe.
----------------------------------------------------------------------------------------------------------------------


-- Iteradores sobre colecciones
helper context ATL!IteratorExp def: iteratorOperator() : String =
	'_->`' + self.name + '_'
;	

helper context ATL!OperationCallExp def: esPredefinida() : Boolean =
	 self.operationName = 'allInstances' or self.operationName = 'oclIsKindOf' or self.operationName = 'oclIsTypeOf' 
	 	or self.operationName = 'size' or self.operationName = 'concat'
		or self.operationName = 'substring' or self.operationName = 'toInteger' or self.operationName = 'toReal'
		or self.operationName = 'oclIsUndefined' or self.operationName = 'oclIsInvalid' or self.operationName = 'abs'
		or self.operationName = 'floor' or self.operationName = 'round' or self.operationName = 'max'
		or self.operationName = 'min' or self.operationName = 'div' or self.operationName = 'mod'
		or self.operationName = 'sin' or self.operationName = 'cos' or self.operationName = 'tan'
		or self.operationName = 'asin' or self.operationName = 'acos' or self.operationName = 'atan'
		or self.operationName = 'sqrt' or self.operationName = 'exp' or self.operationName = 'log'
		or self.operationName = 'rem' or self.operationName = 'pow' or self.operationName = 'toString'
		;

helper context ATL!OperationCallExp def: funcionPredefinida() : String =
	if self.operationName = 'allInstances' then '_.`' + self.operationName
	else 
		if self.operationName = 'substring' then '_.`' + self.operationName + '`(_`,_`)'		
		else
			if self.operationName = 'concat' or self.operationName = 'max' or self.operationName = 'min' or self.operationName = 'div' 
					or self.operationName = 'mod' or self.operationName = 'oclIsKindOf' or self.operationName = 'oclIsTypeOf'
					or self.operationName = 'rem' or self.operationName = 'pow'
				then '_.`' + self.operationName + '`(_`)'
			else '_.`' + self.operationName + '`(`)'
			endif
		endif
	endif;

--helper context ATL!OperationCallExp def: argumentsOperator() : String =


helper context ATL!Primitive def: primitiveName() : String =
	if self.oclIsTypeOf(ATL!StringType) then 'String'
	else
		if self.oclIsTypeOf(ATL!BooleanType) then 'Boolean'
		else
			if self.oclIsTypeOf(ATL!IntegerType) then 'Integer'
			else
				'Real'
			endif
		endif
	endif;

helper context ATL!Primitive def: primitiveType() : Maude!Sort =
	if self.oclIsTypeOf(ATL!StringType) then thisModule.stringSort
	else
		if self.oclIsTypeOf(ATL!BooleanType) then thisModule.boolSort
		else
			if self.oclIsTypeOf(ATL!IntegerType) then thisModule.intSort
			else
				thisModule.realSort
			endif
		endif
	endif;

helper context ATL!PrimitiveExp def: primitiveExpType() : Maude!Sort =
	if self.oclIsTypeOf(ATL!StringExp) then thisModule.stringSort
	else
		if self.oclIsTypeOf(ATL!BooleanExp) then thisModule.boolSort
		else
			if self.oclIsTypeOf(ATL!IntegerExp) then thisModule.intSort
			else
				thisModule.realSort
			endif
		endif
	endif;

	


--helper context ATL!CollectionType def: collectionName() : String =
--	if self.oclIsTypeOf(ATL!BagType) then 'Bag'
--	else
--		if self.oclIsTypeOf(ATL!SetType) then 'Set'
--		else
--			if self.oclIsTypeOf(ATL!SequenceType) then 'Sequence'
--			else
--				'OrderedSet'
--			endif
--		endif
--	endif;

helper context ATL!CollectionType def: collectionType() : Maude!Sort =
	if self.oclIsTypeOf(ATL!BagType) then thisModule.bagSort
	else
		if self.oclIsTypeOf(ATL!SetType) then thisModule.setSort
		else
			if self.oclIsTypeOf(ATL!SequenceType) then thisModule.sequenceSort
			else
				thisModule.orderedSetSort
			endif
		endif
	endif;

--operadores aritm�ticos y l�gicos
helper context ATL!OperatorCallExp def: operatorName() : String =
	if self.operationName='not' then self.operationName + '_'
	else
		if self.operationName='=' then '_.' + self.operationName + '._'
		else
			if (self.operationName='-') and (self.arguments->isEmpty()) then '-_'
			else
				if self.operationName='div' then '_.`'+self.operationName+'`(_`)'
				else
					'_' + self.operationName + '_'
				endif
			endif
		endif
	endif;


helper context String def: numberOfArguments() : Integer =
	if self='insertAt' or self='subSequence' or self='subOrderedSet' then 3
	else
		if self='size' or self='isEmpty' or self='notEmpty' or self='sum' or self='first' or self='last' 
			or self='asSet' or self='asOrderedSet' or self='asBag' or self='asSequence' or self='flatten' then 1
		else
			2
		endif
	endif;


--Operadores sobre coleccones
helper context ATL!CollectionOperationCallExp def: collectionOperator() : String =
	if self.operationName.numberOfArguments()=1 then '_->`' + self.operationName + '`(`)'
	else
		if self.operationName.numberOfArguments()=3 then '_->`' + self.operationName + '`(_`,_`)'
		else
			'_->`' + self.operationName + '`(_`)'
		endif
	endif;


helper context ATL!CollectionExp def: collectionExpOperator() : String =
	if self.oclIsTypeOf(ATL!SetExp) then 'Set`{_`}'  --'Set_'
	else 
		if self.oclIsTypeOf(ATL!SequenceExp) then 'Sequence`{_`}'  --'Sequence_'
		else
			if self.oclIsTypeOf(ATL!BagExp) then 'Bag`{_`}' --'Bag_'
			else
				'OrderedSet`{_`}' --'OrderedSet_'
			endif
		endif
	endif;


helper context ATL!CollectionExp def: collectionExpType() : Maude!Sort =
	if self.oclIsTypeOf(ATL!SetExp) then thisModule.setSort
	else 
		if self.oclIsTypeOf(ATL!SequenceExp) then thisModule.sequenceSort 
		else
			if self.oclIsTypeOf(ATL!BagExp) then thisModule.bagSort
			else
				thisModule.orderedSetSort
			endif
		endif
	endif;

helper context ATL!CollectionExp def: emptyListOperator() : String =
	if self.oclIsTypeOf(ATL!SetExp) or self.oclIsTypeOf(ATL!BagExp) then 'mt'--'`{`}'
	else 'mt-ord'--'`[`]'
	endif;

--helper context ATL!CollectionExp def: itemListType() : Maude!Sort =
--	if self.oclIsTypeOf(ATL!SetExp) or self.oclIsTypeOf(ATL!BagExp) then thisModule.itemListSort
--	else thisModule.itemListOrdSort
--	endif;

--helper context ATL!CollectionExp def: itemListOperator() : String =
--	if self.oclIsTypeOf(ATL!SetExp) or self.oclIsTypeOf(ATL!BagExp) then '`{_`}'
--	else '`[_`]'
--	endif;

helper context ATL!CollectionExp def: listOperator() : String =
	if self.oclIsTypeOf(ATL!SetExp) or self.oclIsTypeOf(ATL!BagExp) then '_;_'  --'_#_'
	else '_#_'  --'_;_'
	endif;

helper context ATL!CollectionExp def : listType() : Maude!Sort =
	if self.oclIsTypeOf(ATL!SetExp) or self.oclIsTypeOf(ATL!BagExp) then thisModule.mSetSort --thisModule.listSort
	else thisModule.listSort --thisModule.listOrdSort
	endif;
	
helper context ATL!PrimitiveExp def : primitiveExpValue() : String =
	if self.oclIsTypeOf(ATL!BooleanExp) then self.booleanSymbol.toString()
	else
		if self.oclIsTypeOf(ATL!StringExp) then '"' + self.stringSymbol + '"'
		else
			if self.oclIsTypeOf(ATL!IntegerExp) then self.integerSymbol.toString()
			else
				self.realSymbol.toString()
			endif
		endif
	endif;

helper context ATL!VariableExp def: esVariableDeLet() : Boolean =
	self.referredVariable.oclIsTypeOf(ATL!VariableDeclaration) and (not self.referredVariable.letExp.oclIsUndefined());

helper context ATL!VariableExp def: noEsVariableDeLet() : Boolean =
	self.referredVariable.oclIsTypeOf(ATL!VariableDeclaration) and self.referredVariable.letExp.oclIsUndefined();

helper context ATL!VariableExp def: esVariableDeIterate() : Boolean =
	self.referredVariable.oclIsTypeOf(ATL!VariableDeclaration) and (not self.referredVariable.baseExp.oclIsUndefined());

helper context ATL!VariableExp def: noEsVariableDeIterate() : Boolean =
	self.referredVariable.oclIsTypeOf(ATL!VariableDeclaration) and self.referredVariable.baseExp.oclIsUndefined();

--helper context ATL!OclType def: helperType() : Maude!Sort =
--	if self.oclIsTypeOf(ATL!Primitive) then self.primitiveType()
--	else
--		self.
--	endif;


--- Este helper va a ser llamado por diferentes reglas, se le pasar� un elemento subtipo de OclExpression y llamar� a
--- la regla que se encarga de transformar dicho elemento seg�n su tipo concreto.
--- En un principio las transformaciones de OCL se realizaron con matched rules que era la soluci�n �ptima.
--- Fue necesario implementar una soluci�n con lazy rule debido a que es necesario asignar las expresiones OCL en diferentes
--- puntos de la transformaci�n, por lo que hab�a que replicarlas.
--- Se intent� poner todas las lazy rules con el mismo nombre para evitar hacer la discriminaci�n de tipos que realiza este helper
--- pero no funcionaba correctamente. Consultando el foro oficial se encontro informaci�n de que no puede haber reglas con el mismo nombre

helper context ATL!OclExpression def: oclExpConverter() : Maude!Term =
	if self.oclIsKindOf(ATL!CollectionExp) then thisModule.CollectionExp2RecTerm(self)
	else
		if self.oclIsTypeOf(ATL!CollectionOperationCallExp) then thisModule.CollectionOperationCallExp2RecTerm(self)
		else
			if self.oclIsTypeOf(ATL!OperatorCallExp) then thisModule.OperatorCallExp2RecTerm(self)
			else
				if self.oclIsTypeOf(ATL!OperationCallExp) then
					if self.operationName='random' and self.source.auxNumberOfRandoms() then thisModule.OperationCallRandom(self)					
					else
						if self.operationName='expDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationCallExpDistribution(self)
						else
							if self.operationName='weibDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationCallWeibDistribution(self)
							else
								if self.operationName='normDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationCallNormDistribution(self)
								else
									if self.operationName='gammaDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationCallGammaDistribution(self)
									else
										if self.operationName='chiSDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationChiSDistrDistribution(self)
										else
											if self.operationName='erlangDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationErlangDistrDistribution(self)
											else
												if self.operationName='fDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationFDistrDistribution(self)
												else
													if self.operationName='geomDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationGeomDistrDistribution(self)
													else
														if self.operationName='logNormDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationLogNormDistrDistribution(self)
														else
															if self.operationName='pascalDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationPascalDistrDistribution(self)
															else
																if self.operationName='paretDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationParetDistrDistribution(self)
																else
																	if self.operationName='unifDistr' and self.source.auxNumberOfRandoms() then thisModule.OperationUnifDistrDistribution(self)
																	else
																		if self.operationName='doublePDF' and self.source.auxNumberOfRandoms() then thisModule.OperationDoublePDFDistribution(self)
																		else
																			if self.operationName='parseExp' and self.source.auxNumberOfRandoms() then thisModule.OperationParseExp(self)
																			else
																				if self.esPredefinida() then thisModule.OperationCallExpPredefinida2RecTerm(self)
																				else thisModule.OperationCallExp2RecTerm(self)
																				endif
																			endif
																		endif
																	endif
																endif
															endif
														endif
													endif
												endif
											endif
										endif
									endif
								endif
							endif
						endif
					endif
				else
					if self.oclIsTypeOf(ATL!VariableExp) then
						--if (not self.referredVariable.oclIsTypeOf(ATL!Parameter)) then	thisModule.VarExpVarDecl2Constant(self)
						if (self.referredVariable.oclIsTypeOf(ATL!Iterator) or self.esVariableDeLet() or self.esVariableDeIterate() 
							or self.referredVariable.varName='self' or self.isAllInstances() or self.isOclIsTypeKindOf()) then--or self.nombreClase())
								thisModule.VarExpVarDecl2Constant(self)
						else thisModule.VarExpIterator2Variable(self)
						endif
					else
						if self.oclIsTypeOf(ATL!IteratorExp) then thisModule.IteratorExp2RecTerm(self)
						else
							if self.oclIsTypeOf(ATL!NavigationOrAttributeCallExp) then thisModule.NavigationOrAttributeCallExp2RecTerm(self)
							else
								if self.oclIsTypeOf(ATL!EnumLiteralExp) then thisModule.EnumLiteralExp2RecTerm(self)
								else
									if self.oclIsKindOf(ATL!PrimitiveExp) then thisModule.PrimitiveExp2RecTerm(self)
									else
										if self.oclIsTypeOf(ATL!LetExp) then thisModule.LetExp2RecTerm(self)
										else
											if self.oclIsTypeOf(ATL!IfExp) then thisModule.IfExp2RecTerm(self)
											else
												thisModule.IterateExp2RecTerm(self)
	--											if att.initExpression.oclIsTypeOf(ATL!IterateExp) then thisModule.IterateExp2RecTerm(att.initExpression)
	--											else																
	--											endif
											endif
										endif
									endif
								endif
							endif												
						endif		
					endif	
				endif
			endif
		endif	
	endif
;

--Estos helpers se utilizan para lo siguiente:					
--Si una operaci�n OCL tiene como argumento una clase, a dicha clase se le asigna un nombre especial del tipo
--NombreDeLaClase@PaqueteDeLaClase

helper context ATL!VariableExp def: variableName() :	Boolean =
	if self.isAllInstances() then 
		self.referredVariable.varName+'@'+self.packageName()
	else 
		if self.isOclIsTypeKindOf() then 
			self.referredVariable.varName+'@'+self.packageName()
		else
			self.referredVariable.varName.processSpecOpChars()
		endif
	endif;

helper context ATL!VariableExp def: isAllInstances() :	Boolean =
	if (not self.appliedProperty.oclIsUndefined()) then 
		if (self.appliedProperty.oclIsTypeOf(ATL!OperationCallExp)) then
			(self.appliedProperty.operationName='allInstances')
		else false
		endif
	else false
	endif;


helper context ATL!VariableExp def: isOclIsTypeKindOf() :	Boolean =
	if (not self.parentOperation.oclIsUndefined()) then
		(self.parentOperation.operationName='oclIsTypeOf' or self.parentOperation.operationName='oclIsKindOf')		
	else
		false
	endif;
----------------------------------------------------------------------------------------------------------------



--El Parser de OCL introduce todas las expresiones OCL (excepto las que son un helper)
--en un elemento de tipo Attribute, es decir Attribute ser� el contenedor de dichas expresiones

rule Att2RecTerm{
	from
		att : ATL!Attribute 
	to
		
		eq : Maude!Equation (
			lhs <- recTerm,
			rhs <- thisModule.Type2Constant(att.type),--att.type,
			"module" <- thisModule.oclModule
			),
		recTerm : Maude!RecTerm(
			op <- att.name,
			type <- thisModule.oclExpSort,
			args <- att.initExpression.oclExpConverter() --thisModule.OclExp2Maude(att.initExpression)
			)
}

-- La he puesto lazy porque en la expression Let tengo un conflicto:
-- en OCL se indica el tipo de la variable pero en mOdCL no, si pongo una regla normal me crea los tipos sueltos
lazy rule Type2Constant{
	from
		t : ATL!Primitive
	to
		cte : Maude!Constant(
			op <- t.primitiveName(),
			type <- t.primitiveType()
			)
}


--lazy rule OperationCallExp2RecTerm{ --OperationCallExp definidas por usuario
--	from		
--		opCallExp : ATL!OperationCallExp --((not opCallExp.esPredefinida()) and (opCallExp.oclIsTypeOf(ATL!OperationCallExp)))
--	using{
--			opArgs : Sequence(ATL!OclExpression) = opCallExp.arguments->subSequence(1,opCallExp.arguments->size()-1);
--		}
--	to		
--		wrapper : Maude!RecTerm(
--			op <- thisModule.navOperator, -- !!!! Operador de la forma (op __: Ocl-Exp Ocl-Exp -> Ocl-Exp) que yo me he creado porque no s� el correcto!!!! !!COMPROBAR!!
--			type <- thisModule.oclExpSort,
--			args <- --Sequence{opCallExp.source,function}
--					Sequence{opCallExp.source.oclExpConverter(),function}
--			),
--		function : Maude!RecTerm(
--			op <- thisModule.functionOperator, -- '._`(`)'
--					--if opCallExp.esPredefinida() then opCallExp.funcionPredefinida(),--opCallExp.operationName,
--					--else thisModule.functionOperator
--					--endif,
--			type <- thisModule.userOpNavSort,
--			args <- Sequence{functionName,opCallExp.arguments->collect(i|i.oclExpConverter())} --comprobar/preguntar: �si alguno es nil esto da problemas?
--																							--�poner tambi�n opCallExp.arguments?
--			),
--		functionName : Maude!Constant( -- Esto es la funci�n de usuario
--			op <- opCallExp.operationName.processSpecOpChars(),
--			type <- thisModule.opNameSort
--			)
--	do{


--		if (opCallExp.arguments.size() = 1){
--			function.op <- '._`(_`)';
--		}
--		if (opCallExp.arguments.size() > 1){
--			function.op <- '._`(_';
--			--for (i in opCallExp.arguments){
--			for (i in opArgs){
--				function.op <- function.op.concat(',_');
--			}
--			function.op <- function.op.concat('`)');	
--		}
--	}
--}
lazy rule OperationCallExp2RecTerm{ --OperationCallExp definidas por usuario
	from		
		opCallExp : ATL!OperationCallExp --((not opCallExp.esPredefinida()) and (opCallExp.oclIsTypeOf(ATL!OperationCallExp)))
	using{
			opArgs : Sequence(ATL!OclExpression) = opCallExp.arguments->subSequence(1,opCallExp.arguments->size()-1);
		}
	to		
		wrapper : Maude!RecTerm(
			op <- thisModule.navOperator, -- !!!! Operador de la forma (op __: Ocl-Exp Ocl-Exp -> Ocl-Exp) que yo me he creado porque no s� el correcto!!!! !!COMPROBAR!!
			type <- thisModule.oclExpSort,
			args <- --Sequence{opCallExp.source,function}
					Sequence{opCallExp.source.oclExpConverter(),function}
			),
		function : Maude!RecTerm(
			op <- --thisModule.functionOperator, -- '._`(`)'
					if opCallExp.arguments->isEmpty() then thisModule.functionOperator
					else thisModule.functionOperatorWithArgs
					endif,
			type <- thisModule.userOpNavSort,
			args <- --Sequence{functionName,opCallExp.arguments->collect(i|i.oclExpConverter())} --comprobar/preguntar: �si alguno es nil esto da problemas?
					if opCallExp.arguments->isEmpty() then functionName
					else 
						if opCallExp.arguments->size()=1 then Sequence{functionName,opCallExp.arguments->first().oclExpConverter()}
						else Sequence{functionName,thisModule.OperationCallExpArguments(opCallExp)}
						endif
					endif																							
			),
		functionName : Maude!Constant( -- Esto es la funci�n de usuario
			op <- opCallExp.operationName.processSpecOpChars(),
			type <- thisModule.opNameSort
			)
}

lazy rule OperationCallExpArguments{
	from
		opCallExp : ATL!OperationCallExp
	to
		list : Maude!RecTerm(
			op <- thisModule.featOperator, --thisModule.setOperator,--thisModule.listOpmOdCL,--'_`,_',
			type <- thisModule.listSort,
			args <- opCallExp.arguments->collect(i|i.oclExpConverter())
			)		
}




lazy rule OperationCallExpPredefinida2RecTerm{ --OperationCallExp PREdefinidas
	from
		opCallExp : ATL!OperationCallExp --((opCallExp.esPredefinida()) and (opCallExp.oclIsTypeOf(ATL!OperationCallExp)))
	to
		function : Maude!RecTerm(
			op <- opCallExp.funcionPredefinida(), --El operador es diferente seg�n la funci�n sea allInstances,concat,substring o el resto					
			type <- thisModule.oclExpSort,
			args <- --Sequence{opCallExp.source,opCallExp.arguments}
					Sequence{opCallExp.source.oclExpConverter(),opCallExp.arguments->collect(i|i.oclExpConverter())}
			--Aqu� opCallExp.source me va a dar qui�n llama a la expresi�n. Por definici�n todas las funciones predefinidas
			--van a poder ser llamadas por una OCL-Exp excepto allInstances que va ser llamada por un Cid (id de Clase)
			--Tal y como est� ahora el type es siempre un OCL-Exp y no es siempre!!!!! (x ej en allInstances el type deber�a ser Cid)
		)
}

lazy rule OperationCallRandom{
	from
		opRandom : ATL!OperationCallExp
	to
		rem : Maude!RecTerm(
			op <- '_rem_',
			type <- thisModule.ratSort,
			args <- Sequence{left,right}
					--Sequence{left,opRandom.arguments->first().oclExpConverter()}
			),
		left : Maude!RecTerm(
			op <- 'random',
			type <- thisModule.intSort,
			args <- Sequence{add}
			),
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			),
		right : Maude!RecTerm(
			op <- thisModule.evalOperator,
			type <- thisModule.oclExpSort,
			args <- Sequence{opRandom.arguments->first().oclExpConverter(),arg2,modelArg}
			),
		arg2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyArg
			),
		emptyArg : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		modelArg : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationCallExpDistribution{
	from
		opRandom : ATL!OperationCallExp
	to
		left : Maude!RecTerm(
			op <- 'expDistr',
			type <- thisModule.intSort,
			args <- Sequence{thisModule.DistributionArguments(opRandom.arguments->first()),add}
					--Sequence{right,add}
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}


lazy rule OperationCallWeibDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'weibDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}


lazy rule OperationCallNormDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'normDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}


lazy rule OperationCallGammaDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'gammaDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationChiSDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'chiSDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationErlangDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'erlangDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}


lazy rule OperationFDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'fDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationGeomDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'geomDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}


lazy rule OperationLogNormDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'logNormDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationPascalDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'pascalDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationParetDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'paretDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationUnifDistrDistribution{
	from
		opRandom : ATL!OperationCallExp
	to

		left : Maude!RecTerm(
			op <- 'unifDistr',
			type <- thisModule.intSort,
			args <- Sequence{opRandom.arguments->collect(j|thisModule.DistributionArguments(j)),add}				
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationDoublePDFDistribution{
	from
		opRandom : ATL!OperationCallExp
	to
		left : Maude!RecTerm(
			op <- 'doublePDF',
			type <- thisModule.intSort,
			args <- Sequence{thisModule.DistributionArguments(opRandom.arguments->first()),add}
					--Sequence{right,add}
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule OperationParseExp{
	from
		opRandom : ATL!OperationCallExp
	to
		left : Maude!RecTerm(
			op <- 'parseExp',
			type <- thisModule.intSort,
			args <- Sequence{thisModule.DistributionArguments(opRandom.arguments->first()),add}
			),		
		add : Maude!RecTerm(
			op <- '_+_',
			type <- thisModule.intSort,
			args <- Sequence{rdm,randomes}
			),
		rdm : Maude!Variable(
			name <- 'VALUE@rdm@',
			type <- thisModule.intSort
			),
		randomes : Maude!Constant(
			op <- thisModule.counterRandom.toString(),
			type <- thisModule.intSort
			)
	do{
		thisModule.counterRandom <- thisModule.counterRandom + 1;
	}
}

lazy rule DistributionArguments{
	from
		distrArg : ATL!OclExpression
	to
		arg2 : Maude!RecTerm(
			op <- thisModule.evalOperator,
			type <- thisModule.oclExpSort,
			args <- Sequence{distrArg.oclExpConverter(),env2,modelArg2}
			),
		env2 : Maude!RecTerm(
			op <- thisModule.envOperator,
			type <- thisModule.msgSort,
			args <- emptyArg2
			),
		emptyArg2 : Maude!Constant(
			op <- thisModule.emptyOperator,
			type <- thisModule.emptySetSort
			),		
		modelArg2 : Maude!Variable(
			name <- 'MODEL@',
			type <- thisModule.sortModel
			)
}





lazy rule VarExpVarDecl2Constant{
	from
		varExp : ATL!VariableExp --(varExp.noEsVariableDeLet() and varExp.noEsVariableDeIterate())--(varExp.referredVariable.oclIsTypeOf(ATL!VariableDeclaration)) 
	to	
		cte : Maude!Constant(
			op <- varExp.variableName(),
--					if varExp.isAllInstances() then 
--						varExp.referredVariable.varName+'@'+varExp.packageName()
--					else 
--						if 
--							varExp.isOclIsTypeKindOf() then varExp.referredVariable.varName+'@'+varExp.packageName()
--						else
--							varExp.referredVariable.varName.processSpecOpChars()
--						endif
--					endif,
			type <- --thisModule.oclExpSort
					thisModule.sortOid
			)
}
	
	

lazy rule VarExpIterator2Variable{
	from
		varExp : ATL!VariableExp --(varExp.referredVariable.oclIsTypeOf(ATL!Iterator) or varExp.referredVariable.oclIsTypeOf(ATL!Parameter) or varExp.esVariableDeLet() or varExp.esVariableDeIterate())
	to	
		var : Maude!Variable(
			name <- varExp.referredVariable.varName,
			type <- thisModule.oclTypeSort
--					if varExp.referredVariable.varName = 'T' then thisModule.oclTypeSort
--					else thisModule.sortOid
--					endif
		)
}

-- La variable T es especial, se va a usar en las Ongoing Rules para representar el tiempo trascurrido y su tipo ser�a @TimeInf.
-- Pero hay que tener en cuenta que puede que el usuario defina un elemento del modelo con identificador T. Para un correcto
-- funcionamiento se define @TimeInf como subtipo de OCL-Type y se declara toda variable T como de tipo OCL-Type



lazy rule IteratorExp2RecTerm{
	from
		iterExp : ATL!IteratorExp
	to
		recTerm : Maude!RecTerm(
			op <- iterExp.iteratorOperator(),
			type <- thisModule.oclExpSort,
			args <- --Sequence{iterExp.source,iterVar}
					Sequence{iterExp.source.oclExpConverter(),iterVar}
			),
		iterVar : Maude!RecTerm(
			op <- thisModule.iterVarOperator, -- '_|_'
			type <- thisModule.iterVarSort,
			args <- --Sequence{iterExp.iterators,iterExp.body} --Sequence{iterExp.iterators}->union(Sequence{iterExp.body})
					Sequence{iterExp.iterators->collect(i|thisModule.Iterator2RecTerm(i)),iterExp.body.oclExpConverter()}
			)
}


lazy rule OperatorCallExp2RecTerm{
	from
		opCallExp : ATL!OperatorCallExp
	to
		recTerm : Maude!RecTerm(
			op <- opCallExp.operatorName(), 
			type <- thisModule.oclExpSort,
			args <- if (opCallExp.operationName = '-')and (opCallExp.arguments->isEmpty()) then opCallExp.source.oclExpConverter() --El parser no detecta los n�meros negativos como un elemento 
					else Sequence{opCallExp.source.oclExpConverter(),opCallExp.arguments->collect(i|i.oclExpConverter())}   --(IntegerExp oRealExp) los trata como un OperatorCallExp que 
					endif												   --ser� el signo - que hace referencia a otro elemento (IntegerExp o RealExp) 
																		    --que ser� el n�mero positivo.
			)
}



lazy rule Iterator2RecTerm{
	from
		it : ATL!Iterator
	to
		var : Maude!Constant(
			op <- it.varName.processSpecOpChars(), 
			type <- thisModule.oclExpSort --thisModule.vidSort
			)
	do{
		thisModule.DeclaracionConstante(it.varName);
	}
}

--El iterador de cada funci�n iteradora es una constante y se crea una
--operaci�n por cada una de estas constantes
unique lazy rule DeclaracionConstante{
	from
		varName : String
	to
		oper : Maude!Operation(
			name <- varName.processSpecOpChars(), 
			coarity <- thisModule.vidSort,
			"module" <- thisModule.mainModule--thisModule.oclModule
			)
}



lazy rule NavigationOrAttributeCallExp2RecTerm{
	from
		nav : ATL!NavigationOrAttributeCallExp
	to
		recTerm : Maude!RecTerm(
			op <- thisModule.navOperator,
			type <- thisModule.oclExpSort,
			args <- Sequence{nav.source.oclExpConverter(),oclAttr}
			),
		oclAttr : Maude!RecTerm(
			op <- thisModule.oclAttrOperator, -- '._'
			type <- thisModule.oclAttrSort,
			args <- att
			),
		att : Maude!Constant(
			op <- nav.name.processSpecOpChars()+'@OCLSf',					
			type <- thisModule.attributeNameSort
			)--,
		----------------------------------------------
--		oper : Maude!Operation(
--			name <- nav.name,
--			coarity <- thisModule.sfSort,
--			"module" <- thisModule.main
--			),
--		eq : Maude!Equation(
--			lhs <-
--			rhs <-
--			"module" <-
--			),
}

--rule CollectionType2RecTerm{
--	from
--		colType : ATL!CollectionType
--	to
--		recTerm : Maude!RecTerm(
--			op <- colType.collectionName(),
--			type <- colType.collectionType()--,
--			--args <-
--			)
--}




lazy rule CollectionExp2RecTerm{
	from
		colExp : ATL!CollectionExp
	to
		recTerm : Maude!RecTerm(
			op <- colExp.collectionExpOperator(),
			type <- colExp.collectionExpType(),
			args <- if colExp.elements -> isEmpty() then thisModule.EmptyCollection(colExp)
					else 
						if colExp.elements->size()=1 then 
							--thisModule.SimpleCollection(colExp)
							Sequence{colExp.elements->collect(i|i.oclExpConverter())}
						else
							thisModule.ListOfCollection(colExp)
						endif
					endif
			)
}

lazy rule EmptyCollection{
	from
		colExp : ATL!CollectionExp
	to
--		recTerm : Maude!RecTerm(
--			op <- colExp.itemListOperator(),
--			type <- colExp.itemListType(),
--			args <- emptyListOp
--			),
		emptyListOp : Maude!Constant(
			op <- colExp.emptyListOperator(),
			type <- colExp.listType()
			)
}

--lazy rule SimpleCollection{
--	from
--		colExp : ATL!CollectionExp
--	to
--		recTerm : Maude!RecTerm(
--			op <- colExp.itemListOperator(),
--			type <- colExp.itemListType(),
--			args <- Sequence{colExp.elements->collect(i|i.oclExpConverter())}
--		)
--}

lazy rule ListOfCollection{
	from
		colExp : ATL!CollectionExp
	to
--		itemList : Maude!RecTerm(
--			op <- colExp.itemListOperator(),
--			type <- colExp.itemListType(),
--			args <- list 
--		),
		list : Maude!RecTerm(
			op <- colExp.listOperator(),
			type <- colExp.listType(),
			args <- Sequence{colExp.elements->collect(i|i.oclExpConverter())}
		)
}


lazy rule EnumLiteralExp2RecTerm{
	from
		e : ATL!EnumLiteralExp
	to
		cte : Maude!Constant(
			op <- e.enumLiteralName(),--e.enumLiteralName(),
			type <- thisModule.enumSort
			)
--	do{
--		--thisModule.allEnums->collect(i|i.toString())->any(j|j=e.name).toString().println();
--		--thisModule.allEnums.toString().println();
--		e.enumLiteralName().toString().println();
--	}
}




lazy rule PrimitiveExp2RecTerm{
	from
		p : ATL!PrimitiveExp
	to
		cte : Maude!Constant(
			op <- p.primitiveExpValue(),
			type <- p.primitiveExpType()
			)
}


lazy rule CollectionOperationCallExp2RecTerm{
	from
		col : ATL!CollectionOperationCallExp
	to
		mauCol : Maude!RecTerm(
			op <- col.collectionOperator(),
			type <- thisModule.oclExpSort,
			args <- --Sequence{col.source,col.arguments}
					Sequence{col.source.oclExpConverter(),col.arguments->collect(i|i.oclExpConverter())}
			)
}


lazy rule LetExp2RecTerm{
	from
		letExp : ATL!LetExp
	to
		recTerm : Maude!RecTerm(
			op <- thisModule.letExpOperator, --'let_in_'
			type <- thisModule.letExpSort,
			args <- --Sequence{operandoIzq,letExp.in_}
					Sequence{operandoIzq,letExp.in_.oclExpConverter()}
			),
		operandoIzq : Maude!RecTerm(
			op <- thisModule.vbleDeclOperator, --'_=_'
			type <- thisModule.vbleDeclSort,
			args <- --Sequence{letExp.variable,letExp.variable.initExpression}
					Sequence{thisModule.VariableDeclaration2RecTerm(letExp.variable),letExp.variable.initExpression.oclExpConverter()}
			)
}


lazy rule VariableDeclaration2RecTerm{ --Para la variable que se define en una expresi�n LET
	from
		--vbleDecl : ATL!VariableDeclaration (not vbleDecl.letExp.oclIsUndefined())--ESTO FUNCIONA ---> ((not vbleDecl.type.oclIsUndefined()) and (not vbleDecl.initExpression.oclIsUndefined()))
		vbleDecl : ATL!VariableDeclaration ((not vbleDecl.letExp.oclIsUndefined()) or (not vbleDecl.baseExp.oclIsUndefined()))
	to
--		var : Maude!Variable(
--			name <- vbleDecl.varName,
--			type <- thisModule.vidSort
--			)
		var : Maude!Constant(
			op <- vbleDecl.varName.processSpecOpChars(),
			type <- thisModule.oclExpSort--thisModule.vidSort
			)
	do{
		thisModule.DeclaracionConstante(vbleDecl.varName);
	}
}

--rule VarDeclIterate2RecTerm{
--lazy rule VarDeclIterate2RecTerm{
--	from
--		vbleDecl : ATL!VariableDeclaration (not vbleDecl.baseExp.oclIsUndefined())
--	to
--		var : Maude!Variable(
--			name <- vbleDecl.varName,
--			type <- thisModule.vidSort
--			)
--}


lazy rule IfExp2RecTerm{
	from
		ifExp : ATL!IfExp
	to
		ifMaude : Maude!RecTerm(
			op <- thisModule.ifExpOperator,--'if_then_else_endif'
			type <- thisModule.oclExpSort,
			args <- Sequence{ifExp.condition.oclExpConverter(),ifExp.thenExpression.oclExpConverter(),ifExp.elseExpression.oclExpConverter()}
			)
}


lazy rule IterateExp2RecTerm{
	from
		iterExp : ATL!IterateExp
	to
		iter : Maude!RecTerm(
			op <- thisModule.iterateOperator, -- '_->`iterate_'
			type <- thisModule.oclExpSort,
			args <- --Sequence{iterExp.source,iExp}
					Sequence{iterExp.source.oclExpConverter(),iExp}
			),
		iExp : Maude!RecTerm(
			op <- thisModule.iterateExpOperator, -- '_,_|_'
			type <- thisModule.iterateExpSort,
			args <- --Sequence{iterExp.iterators,acumulador,iterExp.body}
					Sequence{iterExp.iterators->collect(i|thisModule.Iterator2RecTerm(i)),acumulador,iterExp.body.oclExpConverter()}
			),
		acumulador : Maude!RecTerm(
			op <- thisModule.vbleDeclOperator, --'_=_'
			type <- thisModule.vbleDeclSort,
			args <- --Sequence{iterExp.result,iterExp.result.initExpression}
					--Sequence{thisModule.VarDeclIterate2RecTerm(iterExp.result),iterExp.result.initExpression.oclExpConverter()}
					Sequence{thisModule.VariableDeclaration2RecTerm(iterExp.result),iterExp.result.initExpression.oclExpConverter()}
			)
}


--Esta regla transforma los helpers definidos en el Modelo Behavior mediante una expresi�n OCL
rule Operation2RecTerm{
	from
		o : ATL!Operation
	to		
		oper : Maude!Operation(
			name <- o.name.processSpecOpChars(),
			coarity <- thisModule.opNameSort,
			"module" <- thisModule.mainModule--thisModule.oclModule
			),
		eq : Maude!Equation(
			lhs <- lhsEquation,
			rhs <- o.body.oclExpConverter(),
			"module" <- thisModule.mainModule--thisModule.oclModule
			),
		lhsEquation : Maude!RecTerm(
			op <- o.name.processSpecOpChars(),
			type <- if o.returnType.oclIsTypeOf(ATL!OclModelElement) then thisModule.CreateSort(o.returnType) 
					else 
						if o.returnType.oclIsKindOf(ATL!CollectionType) then o.returnType.collectionType()
						else o.returnType.primitiveType()
						endif
					endif,					
			args <- if o.parameters->size() > 1 then thisModule.ListOfArgsHelper(o)
					else Sequence{o.parameters->collect(i|thisModule.Parameter2Variable(i))}
					endif			
--					if o.parameters->isEmpty() then thisModule.ConstantEmpty(' ')
--					else 
--						if o.parameters->size()=1 then thisModule.Parameter2Variable(o.parameters->first())
--						else
--							thisModule.ListOfArgsHelper(o)
--						endif
--					endif
					--Sequence{o.parameters->collect(i|thisModule.Parameter2Variable(i))}
			)		

}

lazy rule ListOfArgsHelper{
	from
		o : ATL!Operation
	to
		list : Maude!RecTerm(
			op	<- thisModule.featOperator, --thisModule.setOperator,
			type <- thisModule.listSort,
			args <- Sequence{o.parameters->collect(i|thisModule.Parameter2Variable(i))}
		)
}

lazy rule Parameter2Variable{
	from
		p : ATL!Parameter
	to
		var : Maude!Variable(
			name <- p.varName,
			type <- thisModule.oclTypeSort --thisModule.vidSort
			)
}

unique lazy rule CreateSort{
	from
		o : ATL!OclModelElement
	to
		d : Maude!Sort(
			name <- o.model.name,
			--"module" <- thisModule.modelModule
			"module" <- thisModule.auxiliaryModule
			)
}